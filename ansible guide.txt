
## What is Ansible
Ansible is a modern IT automation tool which makes your life easier by managing your servers for you. You just need
to define the configuration in which you are interested and ansible will go ahead and do it for you, be it installing
a package or configuring a server application or even restarting a service. Ansible is always ready to manage your
servers.

## Why do we need Ansible

Managing a infrastructure/environment is easy. Managing 5 is do’able. Managing hundreds or more is a painful task without automation.
Ansible is designed to be simple and effective. You can create identical, replicable servers and clusters of servers in a painless and reliable manner

## Ansible offerings

Configuration Management
Deployments
Provisioning
Orchestration :: Different tasks on different hosts

## Why use Ansible

It is a free open source application by RedHat
It is Idempotent which is extremely important and useful 
Cross Platform Support --> Installed ansible in Ubuntu ---> deployments to be done in CentOs/Fedora/RHEL/Windows
Agent-less Architecture 
Highly flexible and configuration management of systems
Large number of ready to use modules for system management 
Custom modules can be added if needed
Configuration roll-back in case of error 
Simple and human readable as it follows YAML langauge
Easy to manage in VCS and easy also easy to build CI pipeline
Self documenting




Selinux :: SeLinux Settings
Control Nodes --
	Managed by Admins which has copies of all projects. 
	Control Node will run playbooks.
	Control Node is the Ansible Server
	
Managed Hosts --
    server will have an IP 11.22.33.111 or DNS bng.gamut.com
	These are servers listed in the host file
	Servers can be clustered and can be in groups for easy deployments
	Authorized_key Module with ask-pass option
	
Modules -- 
	Every action ( task ) which needs to take place from Control Node to Managed Node is done using Ansible Modules
	Hundreds of supported modules are already available for Linux/Windows.
	Custom Modules can also be built using Python
	Modules will inturn have actual tasks they have to perform
	ansible-doc -l ( lists all modules installed )

	Location of all Ansible Modules ::
		https://docs.ansible.com/ansible/latest/modules/modules_by_category.html
		
 Modules:
  ********
  yum module - use for linux m/c
  apt moudle
  ping module
  user
  file
  docker
  docker swarm
  git 

  
		

YAML

    Ansible uses YAML syntax for expressing Ansible playbooks.
	should start with three -
	end with three .
	No tabs
	follows strict indendation, always by 2 spaces
	follows key value pair model. eg training: ansible
	Strings can be without quotes, single quotes and double quotes
	\n characters should be in double quotes
	integers are automatically interpreted, example a = 1
	integers should not be in double quotes, if it is then it is a string
	list represened as below
		- example 1
		- example 2



	ansible-playbook abc.yml --syntax-check


Inventories -- 
	Managed hosts are defined in inventories
	Inventories can be Static or Dynamic. 
		Dynamic inventories 
			Few examples of Dynamic Inventories --> DB, Docker Containers, AWS Public IPs, New Infra with provisioning
			achieved by using external scripts, these scripts are not officially supported by RedHat
	Location of inventory files can be defined in Ansible.cfg file or while execution of playbook
	Inventories can be classified into groups and few examples below








Ansible Facts -- 
		they are variables that are automatically discoverd by ansible while running playbook. It will run setup module by default
		Facts contain host specific information that can be used as variables in plays
		Few facts which will be considered/picked up by ansible from Managed Node::
		host name, ip address, OS version, various system environment variables, number of CPUs, available disk space etc
		use cases: 
			run database update only when available disc space is more than 10GB
			restart the managed host based on the OS version






Gather facts by using below ansible command ::
				ansible bng01.gamut.com -m setup (setup is the module)
				can be accessed through debug module
				
				hosts: all

  # Task: the list of tasks that will be executed within the play, this section
  # can also be used for pre and post tasks
  tasks:
    - name: Show IP Address
      debug:
        msg: "{{ ansible_default_ipv4.address }}"
		
	We can have custom facts as well, but they are useful only on control node. default location of facts is /etc/ansible/facts.d
	if we need these facts in the Managed hosts as well, then we will need to copy this file to the remote machines using file and copy modules
	##name of file is "date"
	#!/bin/bash
	echo [date]
	echo date=`date`
	
	ansible {ip/hostname} -m setup -a 'filter=ansible_local'
	

	
	
	* we can turn off gathering facts by setting them to NO
				gather_facts: no
				
				
Group-Variables --
	
	user = ansible
	key 	value
	gamutwarfile = /opt/gamut/softwares
		
	Host-variables --> Variable in playbooks are very similar to using variables in any programming language like java, python, shell scripting etc. 
	It helps you to use and assign a value to a variable and use that anywhere in the playbook
	These are variables that are declared in the playbook
	Variables in playbook could be path of particular file or deployment location or any other repeated items
	Variables are very helpful in managing ansible playbooks in clean and efficient way
	
	Host-variables examples --> vars, vars_files ( Yaml or txt), vars_prompt ( private /yes or no)
	
	correct naming   :: web_servers, app_servers, webservers
	Incorrect naming :: web server, web.server or app$server
	
	ansible-playbook -i aa/bb/cc -e "{{name}}" ansibletraining.yml 
	
	Precedence     --> CMD (Global Scope ) -- playbook ( play Scope ) -- inventories ( Host Scope )
	Important note --> Playbook should not start with variable. if it starts, then it has to be within quotes.
	Recommended    --> to define group variables under separate directory and not directly under inventory file/s
	
Playbooks --

	Play is set of tasks which should run on hosts as per inventory and sequentially in order
	Playbook is a set of single or multiple plays
	Playbook is heart/core feature of Ansible and is an organized unit of scripts that defines work for a server.
	Playbook is a combination of name, user, hosts, variables, modules, roles
	Playbooks are human-readable and self documented and they follow yaml syntax
	Playbooks are run using ansible-playbook command 
	Playbooks containes plays. 
    Plays are specific to task eg: install git, start docker, stop docker
	
	
    Ansible has lots of built in modules




Playbook --> hosts, user information, modules, tasks, roles
	
Roles --

	Roles are repeated activities which are common for provisioning/deployment process
	This simplifies writing complex playbooks, and it makes them easier to reuse
	Roles are small functionality which can be independently used but have to be used within playbooks.
	Roles are not playbooks and they cant be independently executed
	Ansible Galaxy is the place to find roles
	There are hundreds of predefined roles available in Ansible-Galaxy which can be just used as Plug and Play 
	Note -- Due diligence of private roles needs to be done before integrating them to the playbooks
	
	www.galaxy.ansible.com
	ansible-galaxy install user.appname
	by default, place these roles in /.ansible/roles
	
	

	
	We will create playbook
	we will run playbook
	and we will install Java using role which is integrated in the playbook






A role directory structure contains directories: defaults, vars, tasks, files, templates, meta, handlers. Each directory must contain a main.yml file which contains relevant content. Let’s look little closer to each directory.
defaults: contains default variables for the role. Variables in default have the lowest priority so they are easy to override.
vars: contains variables for the role. Variables in vars have higher priority than variables in defaults directory.
tasks: contains the main list of steps to be executed by the role.
files: contains files which we want to be copied to the remote host. We don’t need to specify a path of resources stored in this directory.
templates: contains file template which supports modifications from the role. We use the Jinja2 templating language for creating templates.
meta: contains metadata of role like an author, support platforms, dependencies.
handlers: contains handlers which can be invoked by “notify” directives and are associated with service.



Module 

Yum module 


---
 - hosts: all
   become: True
   tasks:
     - name: Install apache
       yum:
         name: httpd
         state: present
		 


apt 
  
---
- hosts: localhost
  become: yes
  gather_facts: no  
  vars:
    packages: [vim,make,curl]

  tasks:

  - name: install package
    apt: name={{item}} state=latest
    with_items: packages




---
- name: install Apache webserver
  hosts: databases

  tasks:
       - name: install Apache webserver
         apt:  
          name: apache2  
          State: latest
		  
		  

dnf 

---
- name: install Apache webserver
  hosts: webservers

  tasks:
       - name: install httpd
         dnf:  
          name: httpd  
          State: latest






	 

Files modules
acl – Set and retrieve file ACL information
archive – Creates a compressed archive of one or more files or trees
assemble – Assemble configuration files from fragments
blockinfile – Insert/update/remove a text block surrounded by marker lines
copy – Copy files to remote locations
fetch – Fetch files from remote nodes
file – Manage files and file properties
find – Return a list of files based on specific criteria
ini_file – Tweak settings in INI files
iso_extract – Extract files from an ISO image
lineinfile – Manage lines in text files
patch – Apply patch files using the GNU patch tool
read_csv – Read a CSV file
replace – Replace all instances of a particular string in a file using a back-referenced regular expression
stat – Retrieve file or file system status
synchronize – A wrapper around rsync to make common tasks in your playbooks quick and easy
tempfile – Creates temporary files and directories
template – Template a file out to a remote server
unarchive – Unpacks an archive after (optionally) copying it from the local machine
xattr – Manage user defined extended attributes
xml – Manage bits and pieces of XML files or strings



- name: Change file ownership, group and permissions
  file:
    path: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'

- name: Give insecure permissions to an existing file
  file:
    path: /work
    owner: root
    group: root
    mode: '1777'

- name: Create a symbolic link
  file:
    src: /file/to/link/to
    dest: /path/to/symlink
    owner: foo
    group: foo
    state: link

- name: Create two hard links
  file:
    src: '/tmp/{{ item.src }}'
    dest: '{{ item.dest }}'
    state: hard
  loop:
    - { src: x, dest: y }
    - { src: z, dest: k }

- name: Touch a file, using symbolic modes to set the permissions (equivalent to 0644)
  file:
    path: /etc/foo.conf
    state: touch
    mode: u=rw,g=r,o=r

- name: Touch the same file, but add/remove some permissions
  file:
    path: /etc/foo.conf
    state: touch
    mode: u+rw,g-wx,o-rwx

- name: Touch again the same file, but dont change times this makes the task idempotent
  file:
    path: /etc/foo.conf
    state: touch
    mode: u+rw,g-wx,o-rwx
    modification_time: preserve
    access_time: preserve

- name: Create a directory if it does not exist
  file:
    path: /etc/some_directory
    state: directory
    mode: '0755'

- name: Update modification and access time of given file
  file:
    path: /etc/some_file
    state: file
    modification_time: now
    access_time: now

- name: Set access time based on seconds from epoch value
  file:
    path: /etc/another_file
    state: file
    access_time: '{{ "%Y%m%d%H%M.%S" | strftime(stat_var.stat.atime) }}'

- name: Recursively change ownership of a directory
  file:
    path: /etc/foo
    state: directory
    recurse: yes
    owner: foo
    group: foo

- name: Remove file (delete file)
  file:
    path: /etc/foo.txt
    state: absent

- name: Recursively remove directory
  file:
    path: /etc/foo
    state: absent




#####################################################################################


user module 

---
- hosts: all
  become: True
  tasks:
    - name: add several users
      user:
        name: "{{item.name}}"
        groups: "{{item.groups}}"
        state: absent
      with_items:
        - {name: 'admin',groups: 'root'}
        - {name: 'developer',groups: 'devops'}	
		 






---                               
- name: Create New Users          
  hosts: all                      
  gather_facts: false             
  tasks:                          
    - name: Create Users Task  
      user:                       
        name: bob                 
        state: present            
        password: "{{ default_user_password | password_hash('sha512', 'A512') }}"
        shell: /bin/bash          
...




- name: Creating user "{{ uusername }}" with admin access
  user: 
    name: {{ uusername }}
    password: {{ upassword | password_hash('sha512') }}
    groups: admin append=yes
  when:  assigned_role  == "yes"

- name: Creating users "{{ uusername }}" without admin access
  user:
    name: {{ uusername }}
    password: {{ upassword | password_hash('sha512') }}
  when:  assigned_role == "no"

- name: Expiring password for user "{{ uusername }}"
  shell: chage -d 0 "{{ uusername }}"
  


- name: Create madhead user
  user:
    name: madhead
    password: "{{ 'password' | password_hash('sha512') }}"
    shell: /bin/zsh
    update_password: on_create
  register: madhead
- name: Force madhead to change password
  shell: chage -d 0 madhead
  when: madhead.changed




---
# Generate random password for new_user_name and the new_user_name
# is required to change his/her password on first logon. 

- name: Generate password for new user
  shell: makepasswd --chars=20
  register: user_password

- name: Generate encrypted password
  shell: mkpasswd --method=SHA-512 {{ user_password.stdout }}
  register: encrypted_user_password

- name: Create user account
  user: name={{ new_user_name }}
        password={{ encrypted_user_password.stdout }}
        state=present
        append=yes
        shell="/bin/bash"
        update_password=always
  when: new_user_name is defined and new_user_name in uids
  register: user_created

- name: Force user to change password
  shell: chage -d 0 {{ new_user_name }}
  when: user_created.changed

- name: User created
  debug: msg="Password for {{ new_user_name }} is {{ user_password.stdout }}"
  when: user_created.changed
When you want to create a new user:

ansible-playbook -i hosts.ini create_user.yml --extra-vars "new_user_name=kelvin"



.
└── ssh
    ├── files
    │   ├── user2.pub
    │   ├── user4.pub
    │   └── user6.pub
    ├── tasks
    │   └── main.yml
    └── vars
        └── users.yml

---
- name: Create New Users
  hosts: all
  gather_facts: false
  tasks:
   - name: Create Users Task
      user:
        name: "{{ item }}"
        state: present
        password: "{{ default_user_password | password_hash('sha512', 'A512') }}"
        shell: /bin/bash
        groups: "{{ admin_group }}"
        append: true
      loop:
        - dev01
        - dev02
        - app01
        - app02
...                



[ansible@controller]$ cat ssh/vars/users.yml 
---
users:

  - username: user2
    use_sudo: yes

  - username: user4
    use_sudo: no

  - username: user6
    use_sudo: no



[ansible@controller]$ tree
.
└── ssh
    ├── files
    │   ├── user2.pub
    │   ├── user4.pub
    │   └── user6.pub
    ├── tasks
    │   └── main.yml
    └── vars
        └── users.yml

4 directories, 5 files



 cat  ssh/tasks/main.yml 
---
  - include_vars: users.yml

  
  - name: Create users with home directory
    user: name={{ item.username }} shell=/bin/bash createhome=yes comment='Created by Ansible'
    with_items: '{{users}}'

  - name: Setup | authorized key upload
    authorized_key: user={{ item.username }}
      key="{{ lookup('file', 'files/{{ item.username }}.pub') }}"
    when: '{{ item.use_sudo }} == True'
    with_items: '{{users}}'

  - name: Sudoers | update sudoers file and validate
    lineinfile: "dest=/etc/sudoers
      insertafter=EOF
      line='{{ item.username }} ALL=(ALL) NOPASSWD: ALL'
      regexp='^{{ item.username }} .*'
      state=present"
    when: '{{ item.use_sudo }} == True'
    with_items: '{{users}}'
	





If you need to create a large list of users and groups with the users spread among the different groups, you can use loops. Let's start by creating the groups:

- name: create user groups
  group:
    name: "{{ item }}"
  loop:
    - postgresql
    - nginx-test
    - admin
    - dbadmin
    - hadoop
You can create users with specific parameters like this:

- name: all users in the department
  user:
    name:  "{{ item.name }}"
    group: "{{ item.group }}"
    groups: "{{ item.groups }}"
    uid: "{{ item.uid }}"
    state: "{{ item.state }}"
  loop:
    - { name: 'admin1', group: 'admin', groups: 'nginx', uid: '1234', state: 'present' }
    - { name: 'dbadmin1', group: 'dbadmin', groups: 'postgres', uid: '4321', state: 'present' }
    - { name: 'user1', group: 'hadoop', groups: 'wheel', uid: '1067', state: 'present' }
    - { name: 'jose', group: 'admin', groups: 'wheel', uid: '9000', state: 'absent' }
Looking at the user jose, you may recognize that state: 'absent' deletes this user account, and you may be wondering why you need to include all the other parameters when you're just removing him. It's because this is a good place to keep documentation of important changes for audits or security compliance. By storing the roles in Git as your source of truth, you can go back and look at the old versions in Git if you later need to answer questions about why changes were made.

To deploy SSH keys for some of the users, you can use the same type of looping as in the last example.

- name: copy admin1 and dbadmin ssh keys
  authorized_key:
    user: "{{ item.user }}"
    key: "{{ item.key }}"
    state: "{{ item.state }}"
    comment: "{{ item.comment }}"
  loop:
    - { user: 'admin1', key: "{{ lookup('file', '/data/test_temp_key.pub'), state: 'present', comment: 'admin1 key' }
    - { user: 'dbadmin', key: "{{ lookup('file', '/data/vm_temp_key.pub'), state: 'absent', comment: 'dbadmin key' }
Here, we specify the user, how to find the key by using lookup, the state, and a comment describing the purpose of the key.





Deleting Accounts

---                      
- name: Clean User Accounts
  hosts: all             
  gather_facts: false                                                                                                                  
  become: true           
  tasks:                                          
    - name: Delete Users
      user:              
        name: "{{ item }}"
        state: absent
        remove: true
      loop:              
        - dev01
        - dev02
        - app01
        - app02         
...    





---
- hosts: localhost
  become: yes
  gather_facts: no  

  tasks:
    - name: add several users
      user:
        name: "{{ item }}"
        state: present
        groups: "sudo"
      with_items:
        - testuser1
        - testuser2
		
		
add_users_dict


---
- hosts: localhost
  become: yes
  gather_facts: no  

  tasks:
    - name: add several users
      user:
        name: "{{ item.name }}"
        state: present
        groups: "{{ item.groups }}"
      with_items:
        - { name: 'test1', groups: 'sudo' }
        - { name: 'testuser1', groups: 'root' }



#########################################################




Starting services
Much like packages, Ansible has different modules to start services. Like in our previous example, where we used the package module to do a general installation of packages, the service module does similar work with services, including with systemd and Upstart. (Check the module's documentation for a complete list.) Here is an example:

  - name: start nginx
    service:
      name: nginx
      state: started
You can use Ansible's service module if you are just starting and stopping applications and don't need anything more sophisticated. But, like with the yum module, if you need more options, you will need to use the systemd module. For example, if you modify systemd files, then you need to do a daemon-reload, the service module won't work for that; you will have to use the systemd module.

  - name: reload postgresql for new configuration and reload daemon
    systemd:
      name: postgresql
      state: reload
      daemon-reload: yes
This is a great starting point, but it can become cumbersome because the service will always reload/restart. This a good place to use a handler.

If you used best practices and created your role using ansible-galaxy init "role name", then you should have the full directory structure. You can include the code above inside the handlers/main.yml and call it when you make a change with the application. For example:

handlers/main.yml

  - name: reload postgresql for new configuration and reload daemon
    systemd:
      name: postgresql
      state: reload
      daemon-reload: yes
This is the task that calls the handler:

  - name: configure postgresql
    template:
      src: postgresql.service.j2
      dest: /usr/lib/systemd/system/postgresql.service
    notify: reload postgresql for new configuration and reload daemon


Example 1: Starting Apache Webserver
---
- name: Start service httpd, if not started
  service:
    name: httpd
    state: started
Example 2: Stopping Apache Webserver
---
- name: Stop service httpd
  service:
    name: httpd
    state: stopped
Example 3: Restarting a Network Interface enp2s0
---
- name: Restart network service for interface eth0
  service:
    name: network
    state: restarted
    args: enp2s0




#######################################
copy module


Copy Module
As the name suggests, copy module copies files from one location on the remote machine to a different location on the same machine.

Example 1: Copying Files from Local to Remote Linux
---
- name: Copy file with owner and permissions
  copy:
    src: /etc/files/mohantest.conf
    dest: /srv/mohantest.conf
    owner: mohantest
    group: mohantest
    mode: '0644'
The playbook copies the config file mohantest.conf from /etc/files/ directory to /srv/ directory as mohantest user with 0644 permissions.

Permissions can also be represented using symbolic representation as shown in the last line.

Example 2: Copying Files from Local to Remote Linux
---
- name: Copy file with owner and permissions
  copy:
    src: /etc/files/mohantest.conf
    dest: /srv/mohantest.conf
    owner: mohantest
    group: mohantest
    mode: u=rw, g=r, o=r
The permissions in the previous example can be represented as shown in the last line, The user is assigned read and write permissions, the group is assigned write permissions, and the rest of the world is assigned read permissions.

File Module
The file module is used to carry many file operations including creating files & directories, assigning file permissions, and setting symlinks.

Example 1: Perform Linux File Permissions
---
- name: Change file ownership, group, and permissions
  file:
    path: /etc/mohantest.conf
    owner: mohantest
    group: mohantest
    mode: '0644'
The above play creates a file called mohantest.conf in the /etc directory setting permissions to 0644.

Example 2: Delete Linux File
---
- name: Remove file (delete file)
  file:
    path: /etc/mohantest.conf
    state: absent


######################################
Directory 


Example 3: Create a Directory
---
- name: create a directory if it doesn’t exist
  file:
    path: /etc/mydirectory
    State: directory
    mode: '0777'
This will create a directory in the /etc directory setting permissions to 0777.

Example 4: Recursiverly Delete a Directory
---
- name: Recursively deleting a  directory
  file:
    path: /etc/mohantest.conf
    state: absent




reate Files and Directories with Ansible
To create files of directories, use the file module.

Create a New Directory
For example, to create a new directory.

---
- hosts: webservers
  tasks:

  - name: Create a new directory
    file: 
     path: /opt/app
     state: directory
You can add other attributes such as owner, group and file permissions.

- hosts: webservers
  tasks:

  - name: Create a new directory
    file: 
     path: /opt/web
     state: directory
     owner: www-data
     group: www-data
     mode: 0644
Additionally, you can create directories recursively using the recurse: yes statement.

---
- hosts: webservers
  tasks:

  - name: Create directories recursively
    file: 
     path: /opt/web/app
     state: directory
     owner: www-data
     group: www-data
     mode: 0644
recurse: yes
Create a File
To create a file, use the state: touch option.

---
- hosts: webservers
  tasks:

  - name: Create a new file
    file: 
     path: /opt/web/index.html
     state: touch
owner: www-data
     group: www-data
     mode: 0644





Lineinfile Module
The lineinfile module is helpful when you want to change a single line in a file. It can replace an existing line.

Example 1: Manipulate Files in Linux
---
 - name: Ensure SELinux is set to enforcing mode
  lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: SELINUX=disabled
The play above sets SELINUX value to disabled.

SELINUX=disabled
Example 2: Alter Files in Linux
---
- name: Add a line to a file if the file does not exist, without         passing regexp
  lineinfile:
    path: /etc/hosts
    line: 192.168.1.34 mohantest.com
    create: yes
This adds the entry 192.168.1.34 mohantest.com to the /etc/hosts file.




Archive Module
An Archive module is used for the creation of a compressed archive of a single or multiple files. It assumes the compression source exists is present on the target destination. After archival, the source file can later be deleted or removed using the statement remove=True.

Example 1: Create a Archive File
- name: Compress directory /path/to/mohantest_dir/ into /path/to/mohantest.tgz
  archive:
    path: /path/to/mohantest_dir
    dest: /path/to/mohantest.tgz

This compresses the /path/to/mohantest_dir  directory to /path/to/mohantest.tgz
Example 2: Create a Archive File and Remove
- name: Compress regular file /path/to/mohantest into /path/to/foo.gz and remove it
  archive:
    path: /path/to/mohantest
    dest: /path/to/mohantest.tgz
    remove: yes
In the above play, the source file /path/to/mohantest is deleted after the archival is complete.

Example 3: Create a Archive File
- name: Create a bz2 archive of /path/to/mohantest
  archive:
    path: /path/to/mohantest
    format: bz2
This creates a compressed file in bz2 format from the /path/to/mohantest file.

Git Module
The module manages git checkouts of software repositories.

Example 1: Check Git Repositoires
- git:
    repo: 'https://foosball.example.org/path/to/repo.git'
    dest: /srv/checkout
    version: release-0.22
	


Compress a Directory
Consider a playbook compress.yml below.

---
- hosts: webservers
  tasks:

    • name: Compress a folder
archive:
        path: /opt/data/web
        dest: /tmp/web.gz
The above playbook compresses the /opt/data/web directory and saves it to /tmp/web.gz.

	
Compress a Directory with Format
The default compression format is .gz, however, this can be specified using the format attribute. Sample the next Playbook.

---
- hosts: webservers
  Tasks:

  - name: Create a zip archive 
    archive:
     path: /opt/data/web
     dest: /tmp/web
     format: zip

uncompress a File
You can also uncompress a compressed file using the unarchive attribute. Consider the playbook below.

---
- hosts: webservers
  tasks:

 - name:Uncompress /tmp/web.gz to/opt directory  on Ansible controller
   unarchive:
     src: /tmp/web.bz2
     dest: /opt/
The playbook above uncompresses the file /opt/data/web.gz to /opt on the Ansible controller.

Uncompress a File on Remote Node
To specify the remote source system use the remote_src=yes option.

---
- hosts: webservers
  tasks:

 - name:Uncompress /tmp/web.bz2 to/opt on remote host
   unarchive:
     src: /tmp/web.bz2
     dest: /opt/
     remote_src=yes 	 
	













	
Command Module
One of the most commonly used modules, the command module takes the command name and later followed by a list of arguments. The command is a passed the same way that you’d type in a Linux shell.

Example 1: Run a Command
- name: Executing a command using the command module
  command: cat helloworld.txt
Example 2: Check Uptime of Remote Linux
---
 - name: Check the remote host uptime
    hosts: servers
    tasks:
      - name: Execute the Uptime command over Command module
        register: uptimeoutput
        command: "uptime"

- debug:
          var: uptimeoutput.stdout_lines	




firewalld module 


Managing Firewall with Ansible
Another important task system administrators undertake is the management of the firewall. In Ansible playbooks, this has been made much easier with firewalld and ufw modules. You can configure the firewall to allow or block a port or service or even a source address.

Let’s jump in and have a look at a few examples:

Open/block Port 80 in firewalld
---
- name: Allow port 80 
  hosts: webservers
  tasks: 
   
   -firewalld:
	port: 80/tcp
     permanent: yes
     state: enabled
In the playbook above, port 80 is allowed across the firewall.




e option permanent: yes enforces the firewall rule and makes it persistent across reboots. However, this rule does not apply immediately. It only comes into effect after a reboot. To enforce the rule immediately, use the option immediate: yes.

To specify the addresses allowed, use the source:0.0.0.0/0 statement.

- firewalld:
    source: 192.168.0.0/24
    zone: public
    state: enabled
To specify a range of ports to be allowed to use the port option as follows:

- firewalld:
    port: 213-567/udp
    permanent: yes
    state: enabled
To block the port change the state option to disabled as shown:

-firewalld:
	port: 80/tcp
     permanent: yes
     state: disabled
Add/Block a Service in firewalld
Apart from adding/blocking a port, you can also apply the same rules to a service. And it’s quite simple. Just use the service module and append the service to be added and ensure that the state option is set to enabled.

- firewalld:
    service: https
    permanent: true
    state: enabled
To block the service set the state option to disabled.

- firewalld:
    service: https
    permanent: true
    state: disabled



Schedule Tasks with Ansible
The cron module helps in scheduling jobs in Ansible Playbooks.

Create a Scheduled Task
Consider the playbook below.

---
- hosts: webservers
  tasks:

 - name: Create a scheduled task
   cron:
     name: Run employee attendance
     job: sh /opt/scripts/attendace.sh
      
     month: 4
     day: 5
     hour: 17
     minute: 00
The playbook runs the attendance script on April 5th at 5:00 pm.

Schedule a Script on Specific Date
If you want to schedule this script to run only if the 5th day of April is a Monday, then use the weekday: 1 attribute. 0 denotes Sunday and 6 denotes Saturday according to cron notation.

month: 4
day: 5
hour: 17
minute: 00
weekday: 1
An asterisk (*) in any of these fields indicates any value.

Run a Job on a Date
To run the job on April 5th at 5:00 pm no matter what the weekday is, use the time parameters as shown.

month: 4
day: 5
hour: 17
minute: 00
weekday: *
Execute a Job on Specific Day on Every Month
To execute the cron job on the 5th day of every month at 5:00 pm use the settings below.

month: *
day: 5
hour: 17
minute: 00
weekday: *
Execute a Job on Daily
To execute the cron job daily at 5:00 pm set the time settings as shown:

month: *
day: *
hour: 17
minute: 00
weekday: *
Execute a Job on Every 5 Hours
To execute the cron job every 5 hours, use the step value */5 as shown.

month: *
day: *
hour: */5
minute: *
weekday: *






Managing Storage with Ansible
The lvg module is used to configure LVM volumes and groups.

Create an LVM Volume Group
Consider the playbook below:

---
- hosts: webservers
  tasks: 
    • name: Create lVM volume group
lvg: 
 vg: vg1
 pvs: /dev/sda1
 pesize: 32
This creates a volume group on top of /dev/sda1 partition with a physical extent size of 32 MB.

Once created, use the lvol module to create a logical volume as shown

Create a Logical Volume
---
    - hosts: webservers
      tasks: 

       - name: Create lVM volume
    lvol: 
    vg: vg1
    lv: lvol1
    pvs: /dev/sda1



Managing File Systems with Ansible
To create a file system on a block device, use the filesystem module.

Create a Filesystem
The playbook below creates the filesystem type of xfs on the block volume.

---
    - hosts: webservers
      tasks: 

       - name: Create a filesystem
         filesystem:
         
           fstype: xfs
           dev: /dev/vg1/lvol1
Mount a Filesystem
You can next proceed to mount the block volume using the mount module as shown in the playbook below:

---
    - hosts: webservers
      tasks: 

       - name: Mount a filesystem
         mount:
         
           fstype: xfs
           src: /dev/vg1/lvol1
           path: /opt/web
           state: mounted




###############################################
Loops with items 
############################################

Nessted loop 


---
- name: Demo of with_nested
  hosts: all
  remote_user: root

  vars:
    list1: [1, 2, 3]
    list2: [a, b, c, d]

  tasks:
    - name: Printing message
      debug: msg="Values are {{item[0]}} and {{item[1]}}"
      with_nested:
        - list1
        - list2












multiple_package_withitem


---
 - hosts: all
   become: True
   tasks:
     - name: install packages
       yum: name={{ item }} state=present
       with_items:
          - git
          - docker
          - curl   


multiple_pkgs_array

---
 - hosts: all
   become: True
   vars:
     packages: [git]
   tasks:
       - name: Install packages
         yum: name={{item}} state=installed
         with_items: 
           - "{{ packages }}"
		   
		   
		   
multiple_pkgs_loop

---
 - hosts: all
   become: True
   tasks:
      - name: Install packages
        yum : name={{ item }} state=installed
        loop:
                - git
                - wget 
				
				



####################################################################################################
#########################
Conditional 
#########################



Conditionals in loops
Conditionals can also be used in a loop. Say for instance you have a list of multiple packages that need to be installed on remote nodes.

In the playbook below, we have an array called packages containing a list of packages that need to be installed. These tasks will be carried out one after the other if the required clause is set to True.

---
 - name: Install Software packages
    hosts: all
    vars:
	packages:
    • name: nginx
required: True
    • name: mysql
required: True
    • name: apache
required: False



   tasks:
    • name: Install “{{ item.name }}”on Debian
apt: 
 name: “{{ item.name }}”
 state: present 
When: item.required == True
loop: “{{ packages }}”  


Use Conditionals to Control Play Execution
Just like in programming languages, conditional statements are used when more than one outcome is possible. Let’s have a look at some of the commonly used conditional statements in Ansible playbooks.

When statement
Sometimes, you may want to perform tasks on specific nodes and not others. The 'when' conditional statement is quite easy to use and implement in a playbook. When using the 'when' clause simply declare the condition adjacent to the clause as shown:

when: condition
When the condition is satisfied, then the task is performed on the remote system.

Let’s check out a few examples:

Example 1: Using When Operator
---
- hosts: all

  tasks:
  - name: Install Nginx on Debian
     apt: name=nginx state=present
     when: ansible_os_family == “Debian”
The play above installs Nginx webserver on hosts running the Debian family of distros.

You can also use the OR and AND operator alongside the when the conditional statement.

Example 2: Using AND Operator with When
---
- hosts: all

  tasks:
  - name: Install Nginx on Debian
     apt: name=nginx state=present
     when: ansible_os_family == “Debian” and
           ansible_distribution_version == “18.04”
When using the AND operator, both statements must be satisfied for the task to be executed.

The play above installs Nginx on Nodes running a Debian family of OS which is version 18.04. Obviously, this will be Ubuntu 18.04.

Example 3: Using OR Operator with When
With OR operator, the task is executed if either of the conditions is fulfilled.

---
- hosts: all

  tasks:
  - name: Install Nginx on Debian
     apt: name=nginx state=present
     when: ansible_os_family == “Debian” or
	      Ansible_os_family == “SUSE”
The play above installs Nginx webservers on either Debian or SUSE family of OS or both of them.

NOTE: Always ensure to use the double equality sign == when testing a condition.


apache-conditions.yml


---
- hosts: all
  become: True
  tasks:
    - name: Install Apache server on Linux
      yum:
        name: httpd
        state: present
      when: ansible_os_family == 'RedHat'
    - name: Install Apache server on Ubuntu
      apt:
        name: httpd
        state: present
      when: ansible_os_family == 'Ubuntu'
	   


---
 - hosts: webservers
   become: True
   tasks:
     - name: Install Apache Server
       yum: name=httpd  state=present
       when: ansible_os_family == "RedHat"

     - name: Install Apache on Debian
       apt:
         name: apache2
         state: present
       when: ansible_os_family == "Debian"

     - name: Start and enable Apache on reboot
       service: name=httpd state=started enabled=True
       when: ansible_os_family == "RedHat"

     - name: Start and enable Apache on reboot
       service: name=apache2 state=started enabled=True
       when: ansible_os_family == "Debian"

     - name: Deploy application on Apache server
       copy: src=./index.html dest=/var/www/html

   handlers:
     - name: Restart Apache
       service:
         name: httpd
         state: restarted
		 
		 
		 
  
---
- hosts: all
  become: True
  tasks:
    - include: apache-linux.yml  
      when: ansible_os_family == 'RedHat'
    - include: apache-ubuntu.yml  
      		 





#################################################################################
handlers


---
 - hosts: webservers
   become: True
   tasks:
     - name: Install Apache Server
       yum: name=httpd  state=present
       when: ansible_os_family == "RedHat"

     - name: Install Apache on Debian
       apt:
         name: apache2
         state: present
       when: ansible_os_family == "Debian"

     - name: Start and enable Apache on reboot
       service: name=httpd state=started enabled=True
       when: ansible_os_family == "RedHat"

     - name: Start and enable Apache on reboot
       service: name=apache2 state=started enabled=True
       when: ansible_os_family == "Debian"

     - name: Deploy application on Apache server
       copy: src=./index.html dest=/var/www/html

   handlers:
     - name: Restart Apache
       service:
         name: httpd
         state: restarted




		 

####################################################################################################



Web_Playbook

First playbook



# ------------------------------
#           AFTER
# ------------------------------
-
  name: Deploy a web application
  hosts: db_and_web_server
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=present
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  present
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name='employee_db' state=present

    - name: Create Application DB User
      mysql_user: name='db_user' password='Passw0rd' priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &
      
	  
	  
	  
app.py


# -------------------------------------------------
#
# This is the web application code. DO NOT MODIFY
#
# -------------------------------------------------

from flask import Flask
from flask.ext.mysql import MySQL
app = Flask(__name__)

mysql = MySQL()

# MySQL configurations
app.config['MYSQL_DATABASE_USER'] = 'db_user'
app.config['MYSQL_DATABASE_PASSWORD'] = 'Passw0rd'
app.config['MYSQL_DATABASE_DB'] = 'employee_db'
app.config['MYSQL_DATABASE_HOST'] = 'localhost'
mysql.init_app(app)

conn = mysql.connect()

cursor = conn.cursor()

@app.route("/")
def main():
    return "Welcome!"

@app.route('/how are you')
def hello():
    return 'I am good, how about you?'

@app.route('/read from database')
def read():
    cursor.execute("SELECT * FROM employees")
    row = cursor.fetchone()
    result = []
    while row is not None:
      result.append(row[0])
      row = cursor.fetchone()

    return ",".join(result)

if __name__ == "__main__":
    app.run()






##################################################################



Hosts and variable 


host_vars
ubuntu_server.yml


ansible_ssh_pass: Passw0rd
ansible_host: 192.168.3.34
db_name: employee_db
db_user: db_user
db_password: Passw0rd



playbook.yml



-
  name: Deploy a web application
  hosts: ubuntu_server
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &




##################################################################






-
  name: Deploy a web application
  hosts: ubuntu_server
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - include: tasks/deploy_db.yml

    - include: tasks/deploy_web.yml
	
	

create folder as tasks

deploy_db.yml

	

  - name: Install MySQL database
    apt:
      name: "{{ item }}"
      state:  installed
    with_items:
     - mysql-server
     - mysql-client

  - name: Start Mysql Service
    service:
      name: mysql
      state: started
      enabled: yes

  - name: Create Application Database
    mysql_db: name={{ db_name }} state=present

  - name: Create Application DB User
    mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

	
	


deploy_web.yml


    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &

	  



Roles 

create a folder roles and host_vars 


flask_web/tasks	
mysql_db/tasks	
python/tasks



# ------------------------------
#           AFTER
# ------------------------------
-
  name: Deploy a mysql DB
  hosts: db_server
  roles:
    - python
    - mysql_db


-
  name: Deploy a Web Server
  hosts: web_server
  roles:
    - python
    - flask_web
	
	
	
	
mysql_db/tasks/main.yml

	
    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'	
	
	
	
flask_web/tasks/main.yml

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &	
	
	
	
roles/python/tasks/main.yml




  - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb






mysql-playbook/db-vars.yml


db-vars.yml
db_name: app-db
user_name: dbadmin
password: dbadmin123


--- 
 - hosts: dbserver
   become: True
   vars_files:
      - db-vars.yml
   tasks:

      - name: Install MySql server on Ubuntu
        apt:
          name: "{{item}}"
          state: present
        with_items:
          - mysql-server
          - python-mysqldb
      - name: Start and enable mysql server
        service:
          name: mysql
          state: started
          enabled: True
      - name: Allow mysql to accect conncetions from any host
        lineinfile: dest=/etc/mysql/my.cnf regexp='^bind-address' line='bind-address=0.0.0.0'
      - name: Create db
        mysql_db:
          name: "{{db_name}}"
          state: present
      - name: Create db user
        mysql_user:
          name: "{{user_name}}"
          password: "{{passowrd}}"
          state: present
          priv: 'app-db.*:ALL'











#################################
Async
###############################



-
  name: Deploy a mysql DB
  hosts: db_server
  roles:
    - python
    - mysql_db

-
  name: Deploy a Web Server
  hosts: web_server
  roles:
    - python
    - flask_web

-
  name: Monitor Web Application for 6 Minutes
  hosts: web_server
  command: /opt/monitor_webapp.py
  async: 360
  poll: 0
  register: webapp_result

-
  name: Monitor Database for 6 Minutes
  hosts: db_server
  command: /opt/monitor_database.py
  async: 360
  poll: 0
  register: database_result








#####################################
Serial versus parallel execution in Ansible

#######################################

Some useful things for controlling serial/parallel execution in Ansible.

forks=1 can be set so that one host task is executed at a time until completion before the next task is started.

serial can be set per-play so that all tasks run to completion on one host at a time.

Playbook strategies can be set. The default behavior is linear. A serial strategy is also available. Finally, a free strategy is available that allows hosts to continue running subsequent tasks before all hosts completed the same task.



1. Forks
Forks are the default number of parallel processes to spawn when communicating with remote hosts. If you are orchestrating your playbook across many servers, then you may have noticed that the number of servers where the playbook executes simultaneously is 5. You can increase this number inside the ansible.cfg file:
# ansible.cfg 
forks = 10

or with a command line argument to ansible-playbook with the -f or –forks options. Note that this setting is dependent upon your hardware and software capabilities, such as network bandwidth and memory available on the control machine. Limit your forks according to your available resources.
2. Async
If you are executing a playbook with tasks that are not required by later tasks, or are not required until much later, then you can potentially derive a very significant speedup from the use of async.

Tasks in playbooks block by default, which means the connections stay open until the task is done on each node. With async you can launch a task and then immediately move on to the next task in a playbook.
---  
- hosts: all 
  remote_user: root 

tasks: 
- name: sleep 
  command: /bin/sleep 50 
  async: 60 
  poll: 10 
- name: not waiting for the device to wake up 
  command: /bin/move_on

If you truly do not care if and when the task completes, then you can set the poll value to 0 to ”fire and forget.” On the other hand, you can also employ a bit more responsible ”fire and forget” usage if there is a task occurring much later that does require the first task to eventually succeed.
--- 
- hosts: all 
  remote_user: root 
  tasks: 
  - name: sleep 
    command: /bin/sleep 50 
    async: 60 
    poll: 0 
    register: sleeper 
... 
  - name: waiting for the device to wake up 
    command: /bin/waiting_first 
    async_status: jid={{ sleeper.ansible_job_id }} 
    register: job_result 
    until: job_result.finished 
    retries: 30

This clearly can yield significant execution time improvements, but also requires a certain level of caution and responsibility correlated to the level of ambition implementing this feature.
3. Free Strategy
If you are executing a playbook without inter-node dependencies, such as provisioning and configuring a set of web servers, 
then you probably want each host to execute the playbook as quickly as possible and not wait for the other hosts to finish a task. 
By default, Ansible uses the linear strategy wherein each task waits for every host to finish before moving on to the next task. However, for many situations we just want each host to finish the playbook as quickly as possible. Ansible 2.0 introduced a new free strategy to achieve this.
---  
- name: setup webserver 
  hosts: webservers 
  strategy: free 
  tasks:

For example, if you are installing Apache on ten different servers and one of them has a yum lock, do you really want the other nine servers to wait around on the one server? With this strategy, those other nine servers can finish their tasks without waiting for the one server. For playbooks with inter-node dependencies, this could be dangerous, but for most use cases this is ideal.
4. Disable Fact Gathering
When executing a playbook, the facts are gathered and stored in a local memory cache on the control machine. 
In most instances this is fine, but for large numbers of servers with large sets of facts, this can quickly cause playbook slowdown on the local machine, or even crash the entire playbook due to lack of available memory. If you are not planning on using any facts for a specific playbook task set,
then it is highly advisable to disable the fact gathering for that set of tasks.
--- 
- name: setup postgres 
  hosts: dbservers 
  gather_facts: no 
  tasks:

You can potentially gain massive speedups in playbooks when disabling fact gathering for large sets of servers with large sets of facts. Many playbooks will require facts, but disabling fact gathering for playbooks that do not require them yields significant benefits.
5. Pipelining
Pipelining is the modern Ansible method of speeding up your ssh connections across the network to the managed hosts. It replaces the former Accelerated Mode. It reduces the number of ssh operations required to execute a module by executing many Ansible modules without an actual file transfer.
# ansible.cfg 
pipelining = True

Although this can result in a very significant performance improvement when enabled, there is a substantial caveat to this feature. When using sudo operations in your playbook, you must first disable requiretty in /etc/sudoers on the managed hosts. Pipelining is disabled by default be- cause requiretty is enabled by default for many distros.
6. Development Environment
The previous topics entailed speeding up your Ansible playbook execution, but what about improving your ability to write Ansible playbooks and roles?

The preferred method for developing Ansible playbooks is within the Atom text editor developed by Github Engineering. The auto-indenting and auto- completion it provides are very helpful for developing within Ansible. With the language-ansible package, Atom has complete support for the Ansible language and recognizes all .yml files as Ansible.

Additionally, the linter-ansible-syntax package provides instant feedback on syntax errors, the linter-ansible-linting package provides instant feedback on style warnings, and the ansible-snippets package provides quick module templates within the editor, saving you time typing and looking up documentation.
With this development environment, your playbooks and roles can be developed two or three times as fast compared to classic text editors like vim or emacs.



-
  name: Deploy a web application
  hosts: app_servers
  serial: "20%"
  vars:
    db_name: employee_db
    db_user: db_user
    db_password: Passw0rd
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &
	  
	  
	  
	  
	  
	  
	  
	  
Task: Use free strategy to accomplish this task.	  
	  
	  
	  
	  
-
  name: Deploy a web application
  hosts: app_servers
  vars:
    db_name: employee_db
    db_user: db_user
    db_password: Passw0rd
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &

# ------------------------------
#           AFTER
# ------------------------------
-
  name: Deploy a web application
  hosts: app_servers
  strategy: free
  vars:
    db_name: employee_db
    db_user: db_user
    db_password: Passw0rd
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &	  






##############################
Error handling 

##################################

-
  name: Deploy a web application
  hosts: app_servers
  any_errors_fatal: true
  vars:
    db_name: employee_db
    db_user: db_user
    db_password: Passw0rd
  tasks:
    - name: Install dependencies
      apt: name={{ item }} state=installed
      with_items:
       - python
       - python-setuptools
       - python-dev
       - build-essential
       - python-pip
       - python-mysqldb

    - name: Install MySQL database
      apt:
        name: "{{ item }}"
        state:  installed
      with_items:
       - mysql-server
       - mysql-client

    - name: Start Mysql Service
      service:
        name: mysql
        state: started
        enabled: yes

    - name: Create Application Database
      mysql_db: name={{ db_name }} state=present

    - name: Create Application DB User
      mysql_user: name={{ db_user }} password={{ db_password }} priv='*.*:ALL' host='%' state='present'

    - name: Install Python Flask dependencies
      pip:
        name: '{{ item }}'
        state: present
      with_items:
       - flask
       - flask-mysql

    - name: Copy web-server code
      copy: src=app.py dest=/opt/app.py

    - name: Start web-application
      shell: FLASK_APP=/opt/app.py nohup flask run --host=0.0.0.0 &

    - name: "Send notification email"
      mail:
        to: devops@corp.com
        subject: Server Deployed!
        body: Web Server Deployed Successfully
      ignore_errors: yes



#############################################################
Sample playbooks 

---
- name: install wget
  yum:
    name: wget
    state: present

- name: install openjdk
  yum:
    name: java-1.8.0-openjdk
    state: present

- name: download jenkins.repo
  get_url:
    url: http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo
    dest: /etc/yum.repos.d/jenkins.repo

- name: import jenkins key
  rpm_key:
    state: present
    key: https://jenkins-ci.org/redhat/jenkins-ci.org.key

- name: install jenkins
  yum:
    name: jenkins
    state: present

- name: start jenkins
  systemd:
    name: jenkins
    state: started

- name: enable jenkins
  systemd:
    name: jenkins
    enabled: true

- name: sleep for 30 seconds and continue with play
  wait_for: timeout=30
  delegate_to: localhost

- name: init password jenkin
  shell: cat /var/lib/jenkins/secrets/initialAdminPassword
  changed_when: false
  register: result

- name: print init password jenkins
  debug:
    var: result.stdout






---
- hosts: tomcat
  remote_user: root
  become_method: sudo
  become: yes
  tasks:
    - name: Install java7
      yum:
        name: java-1.7.0-openjdk
        state: present
    - name: Create Linux Group for Tomcat
      group:
         name: tomcat
    - name: Create Linux User for Tomcat
      user:
         name: tomcat
         groups: 
           - tomcat
           - root  
         home: /usr/share/tomcat
    - name: Download tomcat archive
      get_url:
         url: http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.61/bin/apache-tomcat-7.0.61.tar.gz
         dest: /opt/apache-tomcat-7.0.61.tar.gz
    - name: Extract tar file
      command: chdir=/usr/share /bin/tar xvf /opt/apache-tomcat-7.0.61.tar.gz -C /opt/ creates=/usr/share/tomcat
      #- name: Symlink install directory
      #file: src=/opt/apache-tomcat-7.0.61 path=/usr/share/tomcat state=link
    
    - name: Change ownership of Tomcat installation
      file: path=/usr/share/tomcat/ owner=tomcat group=tomcat state=directory recurse=yes

    - name: Configure Tomcat as a service
      copy: src=tomcat-initscript.sh dest=/etc/init.d/tomcat mode=0755  
    - name: Start the tomcat
      service:
         name: tomcat
         state: started
         enabled: yes





  
---
- name: Disable SELinux startup
  selinux: state=disabled
  when: ansible_selinux != false and ansible_selinux['status'] == 'enabled' and ansible_selinux['config_mode'] != 'disabled'
  tags:
      - common
      - selinux

- name: Disable SELinux now
  command: setenforce 0
  when: ansible_selinux != false and ansible_selinux['status'] == 'enabled' and ansible_selinux['mode'] != 'permissive'
  tags:
      - common
      - selinux

- name: YUM Uninstall SELinux
  yum: name=selinux-policy state=absent
  when: ansible_pkg_mgr == "yum"
  tags:
      - common
      - selinux

- name: APT Uninstall SELinux
  apt: name=selinux-policy state=absent
  when: ansible_pkg_mgr == "apt"
  tags:
      - common
      - selinux




	

How to install ansible 

yum install epel-release
 
yum install ansible

# yum -y install python-pip       
# pip install --upgrade pip      
# pip install pywinrm             
# ansible --version  

cat /etc/ansible/hosts

[localhost]
127.0.0.1 ansible_connection=local
  
[web]
192.168.1.92  ansible_user=centos ansible_ssh_private_key_file=/root/mohanaws.pem

[app]
192.168.2.248 ansible_user=centos ansible_ssh_private_key_file=/root/mohanaws.pem





ansible inventory

cmd
ansible all -m ping 
ansible -m setup --tree /tmp/facts localhost
 

Ansible - Software Management



ansible -m yum -a "name=httpd state=present" localhost --become
- name: install the latest version of Apache
  yum:
    name: httpd
    state: latest

ansible -m yum -a "name=tcpdump state=absent" localhost --become



---
# Software playbook
#
-  hosts: all
   become: true
   gather_facts: yes
   tasks:
   - name: Install a list of packages
     yum:
      name:
       - httpd
       - mod_ssl
      state: present


there is two errors in your config.

yum syntax error
with_items is deprecated now.
example:

- name: Install Tools
  yum:
   state: present
   name:
    - telnet
    - htop



ansible-playbook software.yml --become

---
# Software playbook
#

- name: Install required software
  hosts: all

  tasks:
   - yum: 
      name: "{{ packages }}"
      state: present
     vars:
       packages:
        - httpd 
        - git
        - tcpdump
        - php

   - service: 
      name: httpd
      state: started
      enabled: yes


Ansible - Modules

Ping Module
Ping is used when we want to check whether the connection with our hosts defined in the inventory file is established or not.

ansible test-server -m ping -u dev01

setup
The setup module is used when we want to see the information of all the hosts, their configuration, and detailed information.
ansible localhost -m setup --tree /tmp/facts


Yum Module
We use the Yum module to install a service.

ansible localhost -m yum -a "name=httpd state=present" --become

Copy Module
The copy module is often used in writing playbooks when we want to copy a file from a remote server to destination nodes.

For example, suppose we want to copy a file from a remote server to all destination machines.
ansible localhost -m copy -a "src=/tmp/facts/127.0.0.1 dest=/var/www/html/index.html mode=0600 owner=apache group=apache" --become
ansible test-server -m copy -a 'src=/home/dev01/app.txt dest=/tmp' -u dev01


service 

ansible localhost -m service -a "name=httpd state=started enabled=yes" --become

debug 

file 
file – Manage files and file properties

- name: Change file ownership, group and permissions
  file:
    path: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'


- name: Create a symbolic link
  file:
    src: /file/to/link/to
    dest: /path/to/symlink
    owner: foo
    group: foo
    state: link

- name: Remove file (delete file)
  file:
    path: /etc/foo.txt
    state: absent

- name: Recursively remove directory
  file:
    path: /etc/foo
    state: absent

command 
Execute commands on targets

- name: return motd to registered var
  command: cat /etc/motd
  register: mymotd
  
# 'cmd' is module parameter
- name: Run command if /path/to/database does not exist (with 'cmd' parameter).
  command:
    cmd: /usr/bin/make_database.sh db_user db_name
    creates: /path/to/database
	

Shell Module

When we want to run UNIX commands then we use shell module
Execute commands on the shell.
shell :  health.sh arg1 arg1 >> health.log

ansible test-servers -m shell -a 'ls -la' -u ec2-user


Debug Module

To print a msg on hosts we use Debug module.
ansible test-servers -m debug -a 'msg=Hello' -u ec2-user



lineinfile – Manage lines in text files

# NOTE: Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'
- name: Ensure SELinux is set to enforcing mode
  lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: SELINUX=enforcing

- name: Ensure the default Apache port is 8080
  lineinfile:
    path: /etc/httpd/conf/httpd.conf
    regexp: '^Listen '
    insertafter: '^#Listen '
    line: Listen 8080

- name: Ensure we have our own comment added to /etc/services
  lineinfile:
    path: /etc/services
    regexp: '^# port for http'
    insertbefore: '^www.*80/tcp'
    line: '# port for http by default'
	
# NOTE: Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.
- name: Validate the sudoers file before saving
  lineinfile:
    path: /etc/sudoers
    state: present
    regexp: '^%ADMIN ALL='
    line: '%ADMIN ALL=(ALL) NOPASSWD: ALL'
    validate: /usr/sbin/visudo -cf %s



template

template – Template a file out to a remote server

- name: Copy a version of named.conf that is dependent on the OS. setype obtained by doing ls -Z /etc/named.conf on original file
  template:
    src: named.conf_{{ ansible_os_family }}.j2
    dest: /etc/named.conf
    group: named
    setype: named_conf_t
    mode: 0640

- name: Update sshd configuration safely, avoid locking yourself out
  template:
    src: etc/ssh/sshd_config.j2
    dest: /etc/ssh/sshd_config
    owner: root
    group: root
    mode: '0600'
    validate: /usr/sbin/sshd -t -f %s
    backup: yes


synchronize – 
A wrapper around rsync to make common tasks in your playbooks quick and easy
Synopsis	

- name: Synchronization of src on the control machine to dest on the remote hosts
  synchronize:
    src: some/relative/path
    dest: /some/absolute/path
	

- name: Synchronization using rsync protocol on delegate host (pull)
  synchronize:
    mode: pull
    src: rsync://somehost.com/path/
    dest: /some/absolute/path/
  delegate_to: delegate.host	



get_url – Downloads files from HTTP, HTTPS, or FTP to node

- name: Download foo.conf
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf
    mode: '0440'

- name: < Fetch file that requires authentication.
        username/password only available since 2.8, in older versions you need to use url_username/url_password
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf
    username: bar
    password: '{{ mysecret }}'


Git
The git module manages git checkouts of repositories to deploy files or software.

Example 1:
# Example Create git archive from repo
- git:
    repo: https://github.com/ansible/ansible-examples.git
    dest: /src/ansible-examples
    archive: /tmp/ansible-examples.zip
Example 2:
- git:
    repo: https://github.com/ansible/ansible-examples.git
    dest: /src/ansible-examples
    separate_git_dir: /src/ansible-examples.git
This clones a repo with a separate Git directory.



Archive
The archive module creates a compressed archive of one or more files. By default, it assumes the compression source exists on the target.

Example 1:
- name: Compress directory /path/to/foo/ into /path/to/foo.tgz
  archive:
    path: /path/to/foo
    dest: /path/to/foo.tgz
Example 2:
- name: Create a bz2 archive of multiple files, rooted at /path
  archive:
    path:
   - /path/to/foo
    - /path/wong/foo
    dest: /path/file.tar.bz2
    format: bz2
	
	
dnf – Manages packages with the dnf package manager

- name: install the latest version of Apache and MariaDB
  dnf:
    name:
      - httpd
      - mariadb-server
    state: latest


- name: install a modularity appstream with defined stream
  dnf:
    name: '@postgresql:9.6'
    state: present
	
	

blockinfile – Insert/update/remove a text block surrounded by marker lines

This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.


# Before Ansible 2.3, option 'dest' or 'name' was used instead of 'path'
- name: Insert/Update "Match User" configuration block in /etc/ssh/sshd_config
  blockinfile:
    path: /etc/ssh/sshd_config
    block: |
      Match User ansible-agent
      PasswordAuthentication no
	  
	  
- name: Add mappings to /etc/hosts
  blockinfile:
    path: /etc/hosts
    block: |
      {{ item.ip }} {{ item.name }}
    marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.name }}"
  loop:
    - { name: host1, ip: 10.10.1.10 }
    - { name: host2, ip: 10.10.1.11 }
    - { name: host3, ip: 10.10.1.12 }


firewalld – Manage arbitrary ports/services with firewalld


- name: Redirect port 443 to 8443 with Rich Rule
  firewalld:
    rich_rule: rule family=ipv4 forward-port port=443 protocol=tcp to-port=8443
    zone: public
    permanent: yes
    immediate: yes
    state: enabled

- firewalld:
    rich_rule: rule service name="ftp" audit limit value="1/m" accept
    permanent: yes
    state: enabled

yum_repository – Add or remove YUM repositories
- name: Add repository
  yum_repository:
    name: epel
    description: EPEL YUM repo
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/
	



wait_for – Waits for a condition before continuing

- name: Wait for port 8000 of any IP to close active connections, ignoring connections for specified hosts
  wait_for:
    host: 0.0.0.0
    port: 8000
    state: drained
    exclude_hosts: 10.2.1.2,10.2.1.3

# Same as above but you normally have ansible_connection set in inventory, which overrides 'connection'
- name: Wait 300 seconds for port 22 to become open and contain "OpenSSH"
  wait_for:
    port: 22
    host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'
    search_regex: OpenSSH
    delay: 10
  vars:
    ansible_connection: local
	
	
	
cron – Manage cron.d and crontab entries

- name: Ensure a job that runs at 2 and 5 exists. Creates an entry like "0 5,2 * * ls -alh > /dev/null"
  cron:
    name: "check dirs"
    minute: "0"
    hour: "5,2"
    job: "ls -alh > /dev/null"

find – Return a list of files based on specific criteria

- name: Recursively find /tmp files older than 2 days
  find:
    paths: /tmp
    age: 2d
    recurse: yes	

- name: Find /var/log files equal or greater than 10 megabytes ending with .old or .log.gz
  find:
    paths: /var/log
    patterns: '*.old,*.log.gz'
    size: 10m


replace – Replace all instances of a particular string in a file using a back-referenced regular expression

- name: Long form task does not
  replace:
    path: /etc/hosts
    regexp: '\b(localhost)(\d*)\b'
    replace: '\1\2.localdomain\2 \1\2'

- name: Explicitly specifying positional matched groups in replacement
  replace:
    path: /etc/ssh/sshd_config
    regexp: '^(ListenAddress[ ]+)[^\n]+$'
    replace: '\g<1>0.0.0.0'

- name: Explicitly specifying named matched groups
  replace:
    path: /etc/ssh/sshd_config
    regexp: '^(?P<dctv>ListenAddress[ ]+)(?P<host>[^\n]+)$'
    replace: '#\g<dctv>\g<host>\n\g<dctv>0.0.0.0'
	
	
sysctl – Manage entries in sysctl.conf

# Set vm.swappiness to 5 in /etc/sysctl.conf
- sysctl:
    name: vm.swappiness
    value: '5'
    state: present

# Remove kernel.panic entry from /etc/sysctl.conf
- sysctl:
    name: kernel.panic
    state: absent
    sysctl_file: /etc/sysctl.conf


group – Add or remove groups

- name: Ensure group "somegroup" exists
  group:
    name: somegroup
    state: present


Playbook settings

hosts 
Specify the group name specified in the Ansible hosts file.


remote_user 
Specify the remote execution user.
Since Ansible is an SSH connection, it is necessary to set key authentication for the executing user.

sudo   replace with become 

sudo instead of the execution, using the su If you want to change the authority, become_methodin suspecifying the.
By the way, Default of become_methodis, sudohas become.

vars
Declare variables here that are set when executing a module (task).

handlers
task This is the last job that is executed only once when the status is changed in (when a changed event occurs).


tasks
This item is the key to playbook. List the modules to be executed.

when
The task is executed only when the specified condition is met.


with_items
Loop processing.


until
Loop processing.
until Condition that exits from loop (in the following cases, loop until “OK” is output to the standard output)
retries Is the number of retries
delay Is the number of seconds to sleep



import_playbook
Call the specified file as a component.
Creating and including subdivided playbooks for each task requires less impact if each playbook is modified.


name
Used for comments on each item. If you briefly describe the outline of the playbook etc., it will be easier to understand later.

msg

Output a message to standard output. Useful as a pointer for debugging.


debug
The contents can be confirmed if it is given when debugging.
The following example registerchecks whether a variable is assigned to.
Debugging is also possible when ansible-playbook command is executed -vor -vvwhen -vvvgiven.







##############
create a user 

ansible-playbook users.yml --become

---
# Create required users

- name: Create required users
  hosts: all
  vars:
   usernames:  
    - devs
    - security
    - admins


  tasks:
   - group:
      name: web
      state: present

   - user:
      name: "{{ item }}"
      state: present
      groups: web
      append: yes
     with_items: "{{ usernames }}"



Write a Playbook That Removes `tcpdump` When a Server's Name Does Not Contain `admin

# Variables playbook
- name: This playbook will remove tcpdump (if installed) from servers without admin in their hostnames
  hosts: all
  become: yes
  tasks:
   - name: Remove tcpdump from all but admin servers
     yum:
      name: tcpdump
      state: absent
     when: "'admin' not in inventory_hostname"

   - name: Make sure git is installed only on Red Hat servers
     yum:
      name: git
      state: present
     when: ansible_facts['os_family'] == 'RedHat'
	 



for i in webserver dbserver controller;
   do ssh dev01@$i "sudo tar -czf messages.tar.gz /var/log/messages";
done

ansible -m fetch -a "src=/home/dev01/messages.tar.gz dest=/tmp/messages" all




Verify Connectivity in the Environment
On the command line run ansible -m ping all.


Install httpd

Your playbook, apache.yml should look something like this:

---
# Common Modules Playbook
#

- name: Common Modules Playbook
  become: yes
  hosts: webserver

  tasks:
   - name: Install httpd on webserver
     yum:
      name: httpd
      state: present
	  
   - name: Start the httpd service
     service:
      name: httpd
      state: started
      enabled: yes
 
   - name: Create index.html
     file:
      path: /var/www/html/index.html
      state: touch  







Play with Tasks & Handlers

---

- hosts: all
  become: yes

  tasks:
    - name: Install the latest version of Apache
      yum: name=httpd state=latest update_cache=yes
      ignore_errors: yes
      notify: start Apache

  handlers:
    - name: start Apache
      service: name=httpd enabled=yes state=started
	  
	  





################################################################

Conditional Execution Using Facts and When Statement








create a dba user  copy the required file 

---

- name: DB server playbook
  become: yes
  hosts: dbservers

  tasks:
   - name: Add the 'dba' user to the dbservers
      user:
       name: dba
	   
  - name: Copy required DBA files
     copy:
      src: /root/DBAstuff.txt
      dest: /home/dba/
      owner: dba
      group: dba
      mode: 0600
	  

Clone the Ansible Git Repository into /opt on adminservers

Your admin.yml playbook will look something like this:

---

- name: Use git to clone the Ansible repo
  hosts: admins
  become: yes

  tasks:
   - name: Install git
     yum:
      name: git
      state: present

   - name: Use the git module
     git:
      repo: https://github.com/ansible/ansible.git
      dest: /opt
	  
	  



---
 - hosts: all
   tasks:
   - name: hostname
     debug:
       var=ansible_hostname

   - name: date and time
     vars:
      msg: |
       Date: {{ ansible_date_time.date }}
       Timezone: {{ ansible_date_time.tz }}
     debug:
      msg: "{{ msg.split('\n') }}"

   - name: network info
     vars:
      msg: |
       All Interface List: {{ ansible_interfaces }}
       All IP: {{ ansible_all_ipv4_addresses }}
       Gateway: {{ ansible_default_ipv4.gateway }}
       Eth0 MAC: {{ ansible_eth0.macaddress }}
     debug:
      msg: "{{ msg.split('\n') }}"

   - name: OS and Kernel info
     vars:
      msg: |
       Distribution: {{ ansible_distribution }}
       Release: {{ ansible_distribution_release }}
       Distribution Version: {{ ansible_distribution_version }}
       Kernel: {{ ansible_kernel }}
       Architecture: {{ ansible_architecture }}
     debug:
      msg: "{{ msg.split('\n') }}"

   - name: HW info
     vars:
      msg: |
       CPU: {{ ansible_processor }}
       CPU Core: {{ ansible_processor_cores }}
       RAM: {{ ansible_memtotal_mb }}
       SWAP: {{ ansible_memory_mb.swap.total }}
     debug:

      msg: "{{ msg.split('\n') }}"
	  
	  

Check for the Existence of /root/archive.tar and Create It If It Doesn't

This part of the playbook should look something like this:

- name: Common Modules Playbook
  become: yes
  hosts: webserver

  tasks:
   - name: Install httpd on webserver
     yum:
      name: httpd
      state: present
      ignore_errors: true

   - name: Check for archive file
     command: ls /root/archive.tar
     register: check_result
     ignore_errors: true

   - name: Touch archive file
     file:
      path: /root/archive.tar
      state: touch
     when: check_result is failed	 
	 



Add inlinefile module to  insert the index.html 


- name: Install httpd
  hosts: webserver
  become: yes

  tasks:
   - name: httpd install
     yum:
      name: httpd
      state: present

   - name: Service management for httpd
     service:
      name: httpd
      state: started
      enabled: yes   

   - name: Create and populate index.html
     lineinfile:
      path: /var/www/html/index.html
      line: Mohan webserver.
      create: yes
      owner: apache
      group: apache
      mode: 0644    
	  
	  

- name: DB server management
  hosts: dbservers
  become: yes

  tasks:
   - name: Add user
     user:
      name: mysqld
      state: present

   - name: Copy DB user data
     copy:
      src: /root/dba.txt
      dest: /home/mysqld/dba.txt
      owner: mysqld
      group: mysqld
      mode: 0600   


Gather all the redhat machine ip address 
 
	  

- name: Red Hat specific configuration
  hosts: all
  become: yes
  gather_facts: yes

  tasks:
   - name: Populate file with IP addresses
     lineinfile:
      path: /root/addresses
      line: "{{ ansible_facts['all_ipv4_addresses'] }}"
      create: yes
     when: ansible_os_family == "RedHat"



---
 - hosts: all


   tasks:
   - name:  echo distribution - CentOS
     command: echo CentOS-PC
     when: ansible_distribution == "CentOS"  and ansible_architecture == "x86_64"
     register: centos


   - name:  echo distribution - Ubuntu
     command: echo Ubuntu-PC
     when: ansible_distribution == "Ubuntu"  and ansible_architecture == "x86_64"
     register: ubuntu


   - debug: var={{ item }}
     loop:
       - centos.stdout
       - ubuntu.stdout



Firewall httpd open  

---
- name: webserver firewall rules
  hosts: webservers
  become: yes

  tasks:
   - name: ssh firewall rules
     firewalld:
      permanent: yes
      state: enabled
      immediate: yes
      service: ssh

   - name: http firewall rules 
     firewalld:
      permanent: yes
      state: enabled
      immediate: yes
      service: http
	  
	  
	  
	  
Firewall postgresql 

---
 - name: db firewall rules
   hosts: dbservers
   become: yes

   tasks:
   - name: ssh firewall rules
     firewalld:
      permanent: yes
      state: enabled
      immediate: yes
      service: ssh

   - name: postgresql firewall rules 
     firewalld:
      permanent: yes
      state: enabled
      immediate: yes
      service: postgresql 
	  
	  
Selinux enablement
---
- name: SELinux
  hosts: all
  become: yes

  tasks:
   - name: Enable SELinux
     selinux:
      state: enforcing
      policy: targeted


deploy script and execute the scritps 


- name: copy db script
  hosts: dbservers
  become: yes

  tasks: 
   - name: copy deploy script
     script: /root/deploy.sh


- name: copy db script
  hosts: dbservers
  become: yes

  tasks: 
   - name: copy deploy script
#    script: /root/deploy.sh
     copy:
      src: /root/deploy.sh
      dest: /opt/deploy.sh
      owner: root
      group: root
      mode: 0755

   - name: Execute the script
     command: sh /opt/deploy.sh
	 



 ---

- name: copy webapp
  hosts: webservers
  become: yes

  tasks:
   - name: install webapp
     copy:
      src: /root/index2.html
      dest: /var/www/html/index.html
      owner: apache
      group: apache
      mode: 0644




create a users and groups 

---
- name: verify group exists
  hosts: all
  become: yes

  tasks:
   - group: 
      gid: 2000
      name: adminbackup
      state: present
   - group:
      gid: 2001
      name: new_backup
      state: present
   - user:
      name: old_backup
      state: absent
   - user:
      name: servernew_backup
      uid: 2003
      shell: /bin/false
      password_lock: yes
      groups: adminbackup, servernew_backup
	  
	  

start services on two servers 


- name: Start postgresql
  hosts: dbserver:controllerserver
  become: yes

  tasks:
  - systemd:
     name: postgresql
     state: started
     no_block: yes




create a disk and attach to the machine 


---
- name: Disks playbook
  hosts: dbservers
  become: yes
  tasks:
   - name: hostname
     debug:
       var=ansible_hostname

   - name: Create the Volume Group
     lvg:
      vg: RHCE
      pvs: /dev/xvdg

   - name: Create Logical Volume
     lvol:
      lv: AppDB2
      vg: RHCE
      size: 10G
      pvs: /dev/xvdg
      state: present   

   - name: Format the disk
     filesystem:
      dev: /dev/RHCE/AppDB2
      fstype: xfs
  
   - name: Mount the disk
     mount:
      fstype: xfs
      src: /dev/RHCE/AppDB2
      state: mounted
      path: /mnt/appdb2
	  


######################################################################


create a disk and attach to the machine 


---
- name: Disks playbook
  hosts: dbservers
  become: yes
  tasks:
   - name: hostname
     debug:
       var=ansible_hostname

   

   - name: Create the Volume Group
     lvg:
      vg: appvg
      pvs: /dev/xvdf

   - name: Create Logical Volume
     lvol:
      lv: AppDB2
      vg: appvg
      size: 10G
      pvs: /dev/xvdf
      state: present   

   - name: Format the disk
     filesystem:
      dev: /dev/appvg/AppDB2
      fstype: xfs
  
   - name: Mount the disk
     mount:
      fstype: xfs
      src: /dev/appvg/AppDB2
      state: mounted
      path: /mnt/appdb2
	  

######################################

---
- name: Disks playbook
  hosts: web
  become: yes
  tasks:
   - name: hostname
     debug:
       var=ansible_hostname

   - name: yum install lvm package
     when: ansible_os_family == "RedHat"
     yum:
        name: lvm2 
        state: present

   - name: Create the Volume Group
     lvg:
      vg: appvg
      pvs: /dev/xvdf

   - name: Create Logical Volume
     lvol:
      lv: AppDB2
      vg: appvg
      size: 10G
      pvs: /dev/xvdf
      state: present   

   - name: Format the disk
     filesystem:
      dev: /dev/appvg/AppDB2
      fstype: xfs
  
   - name: Mount the disk
     mount:
      fstype: xfs
      src: /dev/appvg/AppDB2
      state: mounted
      path: /mnt/appdb2






#########################################################################



- name: Copy data dev stuff and inflate data and dev stuff
  hosts: dbservers
  become: yes

  tasks:
  - unarchive:
     src: /root/file.tar.gz
     dest: /opt/

 - unarchive:
   src: /tmp/devstuff.tar.gz
   dest: /opt/
   remote_src: yes 
   
  - archive:
    path: /var/log/messages
    dest: /tmp/messages.tar.gz

  - fetch:
     src: /tmp/messages.tar.gz
     dest: /tmp/
	  

###############################################
How to run tasks in parallel?   What if I wan’t to wait until ALL my async’ed/parallelized tasks are finished?

- name: Example of async and poll
  hosts: all
  tasks:
    - name: Run scripts
      command: "/tmp/{{ item }}.sh"
      async: 100
      poll: 25
      with_items:
        - fill_database
        - create_users
      register: result
 

Parallel Playbook Execution

memcache.yml
- name: Install memcache
  apt: name=memcached update_cache=yes
- name: Ensure memcache is started.
  service: name=memcached state=started
  
mongodb.yml
- name: Install mongodb
 apt: name=mongodb update_cache=yes
- name: Ensure mongodb is started.
 service: name=mongodb state=started

provision.yml:
- hosts: mongodb:memcache
  gather_facts: no
  strategy: free
  tasks:
    - include: memcache.yml
      when:  "'memcache' in group_names"
- include: mongodb.yml
      when: "'mongodb' in group_names"
- hosts: app
  tasks:
    ....
	
---

- name: Run tasks in parallel
  hosts: localhost
  connection: local
  gather_facts: no
  tasks:
    - name: Pretend to create instances
      command: "sleep {{ item }}"  # Instead of calling a long running operation at a cloud provider, we just sleep.
      with_items:
        - 6
        - 8
        - 7
      register: _create_instances
      async: 600  # Maximum runtime in seconds. Adjust as needed.
      poll: 0  # Fire and continue (never poll)

    - name: Wait for creation to finish
      async_status:
        jid: "{{ item.ansible_job_id }}"
      register: _jobs
      until: _jobs.finished
      delay: 5  # Check every 5 seconds. Adjust as you like.
      retries: 10  # Retry up to 10 times. Adjust as needed.
      with_items: "{{ _create_instances.results }}"



###############################################
How to template the ansible play books 


###############################################
	  
Encrypt Playbook using Ansible Vault

python -c "from passlib.hash import sha512_crypt; import getpass; print sha512_crypt.encrypt(getpass.getpass())"
Password:
$6$rounds=656000$AmI1LlHNw3l3F7Xb$fDeo0QBtkMkMV02dmDQEn2fS588QZ4R/bDz81FPHJ4Jx2fi7lBE/RS1xbSMYmxD60iDbAqwdaosnC00oG/Vo0/

ansible-vault create reset_root_password.yaml
ansible-vault edit reset_root_password.yaml
ansible-playbook  reset_root_password.yaml --ask-vault-pass -vv
ansible-vault view reset_root_password.yaml
ansible-vault decrypt  reset_root_password.yaml
cat  vault_pass
test123
 
ansible-vault view --vault-id  vault_pass  reset_root_password.yaml

---

 - hosts: web
   become: yes
   gather_facts: no

   tasks:
    -  name: Reset the account password
       user:
         name: root
         update_password: always
         password: test123


###############################################

Create a file in Ansible with timestamp: 

---
- hosts: localhost
  become: no
  gather_facts: yes

  tasks:
   - name: Display the availble timestamp format in Ansible
     debug:
      var=ansible_date_time


---
- hosts: localhost
  become: no
  gather_facts: yes

  tasks:
   - name: Display the available timestamp format in Ansible
     shell: cp /etc/nsswitch.conf  /etc/nsswitch.conf.{{ ansible_date_time.iso8601 }}

   - name: Display the newly created file
     shell: ls -lrt /etc/nsswitch.conf.{{ ansible_date_time.iso8601 }}
     register: LISTFILE

   - debug: msg={{ LISTFILE.stdout }}


##########################################

Store Playbook Result in Variable 

[root@ip-192-168-3-155 demoplay]# cat df.yml
---

 - hosts: all
   become: yes

   tasks:
     - name: Execute /boot usage on Hosts
       command: 'df -h /boot'
       register: dfboot

     - debug: var=dfboot.stdout
     - debug: var=dfboot.stdout_lines


 
 


###################################



Prior to Ansible engine 2.7, To reboot the target hosts, we need to define a block of code to reboot the server and wait until the hosts to come back. Most of the time. 
making the configuration changes or installing the OS patches which require a reboot. Post reboot, we might need to get few commands output to validate those changes. 
we will walk through how Ansible 2.7 engine codes reduce the block of code.





---
- hosts: web
  become: yes

  tasks:
   - name: Check the uptime prior reboot
     shell: uptime
     register: UPTIME_PRE_REBOOT

   - debug: msg={{UPTIME_PRE_REBOOT.stdout}}

   - name: Reboot node and stop polling.
     shell: reboot
     async: 10 # Do not care for 10 sec
     poll: 0 # Fire & Forget

   - name: wait for host to finish reb00t
     wait_for:
      port: "{{ (ansible_port|default(ansible_ssh_port))|default(22) }}"
      host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'
      search_regex: OpenSSH
      delay: 10  # Do not check for at least 10 sec
     connection: local

   - name: Check the uptime post reboot
     shell: uptime
     register: UPTIME_POST_REBOOT

   - debug: msg={{UPTIME_POST_REBOOT.stdout}}
   
   


---
- hosts: web
  become: yes

  tasks:
   - name: Check the uptime
     shell: uptime
     register: UPTIME_PRE_REBOOT

   - debug: msg={{UPTIME_PRE_REBOOT.stdout}}

   - name: Unconditionally reboot the machine with all defaults
     reboot:

   - name: Check the uptime after reboot
     shell: uptime
     register: UPTIME_POST_REBOOT

   - debug: msg={{UPTIME_POST_REBOOT.stdout}}





If you get shut down command not found, you have the following options.

Update Ansible Engine to 2.8. (# yum update ansible) and follow from step number 3.
Use legacy reboot method.
 

If you are running with Ansible engine 2.8, then tweak the playbook like below.

 

3. In Ansible 2.8, Ansible’s reboot module had the option to include the command search path as argument. In my hosts, shutdown command has been kept in /usr/sbin/custom/

---
- hosts: all
  become: yes

  tasks:
   - name: Check the uptime
     shell: uptime
     register: UPTIME_PRE_REBOOT

   - debug: msg={{UPTIME_PRE_REBOOT.stdout}}

   - name: Unconditionally reboot the machine with all defaults
     reboot:
         search_paths: /usr/sbin/custom/

   - name: Check the uptime after reboot
     shell: uptime
     register: UPTIME_POST_REBOOT

   - debug: msg={{UPTIME_POST_REBOOT.stdout}}



###################################

Ansible tags 

https://github.com/88K/tutorials/tree/b79969f2138c3ac50dc4589d6638e321629ba0c8



#############################################

Conditional Execution Using Facts and When Statement


---
- name: Playbook to install apazhe in different OS falvour.
  hosts: web
  become: yes
  tasks:
    - name: Install apache2 Debian
      when: ansible_os_family == "Debian"
      apt:
        name: apache2
        state: present
        update_cache: yes
            
    - name: Debian service restart
      when: ansible_os_family == "Debian"
      service:
        name: apache2
        state: restarted
        enabled: yes
            
    - name: Install httpd Red Hat
      when: ansible_os_family == "RedHat"
      yum:
        name: httpd
        state: present
        
    - name: Redhat service restart
      when: ansible_os_family == "RedHat"
      service:
        name: httpd
        state: restarted
        enabled: yes
            
			
##################################################################			

---
 - name: update centos linux
   hosts: web
   become: yes
   tasks: 
    - name: Update all pkgs - RHEL-Based
      when:
       - ansible_os_family == "RedHat"
      yum:
       name: "*"
       state: latest
      tags:
        - yum
      failed_when: false
    
    - name: add docker repository
      when: ansible_os_family == "RedHat"
      command: /usr/bin/yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
      tags:
       - yum
       - docker
  
    - name: Install base pkgs - RHEL-Based
      when:
      - ansible_os_family == "RedHat"
      yum:
       state: present
       name:
        - telnet
        - htop
        - vim
        - git
        - wget
        - openssh
        - net-tools
      tags:
       with_pkg
      failed_when: false     

    - name: install docker ce
      when: ansible_os_family == "RedHat"
      yum:
       name: docker-ce
       state: latest
       tags:
        - yum
        - docker


#############################################
Include tasks


The playbook written in above example to install httpd in different OS flavour can be written in another way.

# We can split them into 3 different playbooks.


#Debian.yml which will have tasks only for debian falvoured OS
$vim debian.yml

---
- name: Install apache2 Debian
  apt:
    name: apache2
    state: present
    update_cache: yes
            
- name: Debian service restart
  service:
    name: apache2
    state: restarted
    enabled: yes

#Redhat.yml which will have tasks only for RHEL flavoured OS.

$vim redhat.yml

---
- name: Install httpd Red Hat
  yum:
    name: httpd
    state: present
        
- name: Redhat service restart
  service:
    name: httpd
    state: restarted
    enabled: yes



$vim main.yml

---
- name: Install apache on multiple OS flavour
  become: yes
  hosts: web
  tasks:
    - include_tasks: debian.yml
      when: ansible_os_family == "Debian"
    - include_tasks: redhat.yml
      when: ansible_os_family == "RedHat"


#########################################################

Debug module and Register keyword


root@ip-192-168-3-155 demoplay]# cat df.yml
---

 - hosts: all
   become: yes

   tasks:
     - name: Execute /boot usage on Hosts
       command: 'df -h /boot'
       register: dfboot

     - debug: var=dfboot.stdout
     - debug: var=dfboot.stdout_lines


################################################################


Playbook to restart service only when a change is applied.

restart.yml


---
- name: Restart httpd only when a change is applied.
  hosts: web
  become: yes
  tasks:
    - name: Installing LAMP
      yum:
        name:
          - httpd
          - php
          - php-mysql
        state: present
      register: installation_status
    
    - name: Creating PHP file
      copy:
        content: '</php phpinfo(); ?>'
        dest: /var/www/html/index.php
      register: php_content_status
        
    - name: Restarting httpd
      service:
        name: httpd
        state: restarted
      when: installation_status.changed == true or php_content_status.changed == true




######################################################

Jinja2 Templates (template module)

#Here we use a template file(sample.j2) and create it in a VM using the name variable.

---
- hosts: web
  vars:
    name: web
  tasks:
    - name: "Template Demo"
      template: 
         src: sample.j2
         dest: /tmp/{{name}}.txt
		 
		 
################################################################################
https://www.linuxtopic.com/2019/02/ansible-playbook-get-hosts-information.html


Inventory for the server 

---
 - hosts: all
   gather_facts: no
   become: yes
   become_method: sudo
   tasks:

     - name: Getting os version
       shell: cat /etc/*-release | grep "PRETTY_NAME" | sed 's/PRETTY_NAME=//g' | sed 's/"//g'
       register: os

     - name: Getting hostname version
       shell: hostname
       register: hostname

     - name: Getting uname version
       shell: uname -r
       register: uname
  
     - name: Getting uname arc
       shell: uname -p
       register: arc
  
     - name:
       shell: cat /etc/redhat-release
       register: release

     - name:
       shell: rpm -qa | grep curl | grep -v lib | grep -v python
       register: curl
  

     - name: create some file
       local_action: file path=/tmp/rhelroot  state=absent mode=0755
       delegate_to: 192.168.3.155
 
     - name: create some file
       local_action: file path=/tmp/rhelroot  state=touch mode=0755
       delegate_to: 192.168.3.155

     - name: Writing gathered data locally to file.
       local_action: lineinfile line="{{ hostname.stdout, os.stdout,  uname.stdout, arc.stdout,  curl.stdout   }}" insertafter=EOF dest=/tmp/rhelroot



##################################################
Waiting with Ansible, pausing a Playbook 

---
- hosts: all
  tasks:
    - name: check date
      command: date
      register: out
    - debug: msg={{out.stdout}}
 
    - pause: seconds=3
 
    - name: check date
      command: date
      register: out
    - debug: msg={{out.stdout}}

###################################################
https://www.theurbanpenguin.com/managing-users-in-ansible/

https://github.com/jmutkawoa/My-Ansible-Playbooks

https://www.linuxsysadmins.com/creating-logical-volume-based-file-system-using-ansible/

https://www.linuxsysadmins.com/splunk-forwarder-installation-using-ansible/
https://zhuanlan.zhihu.com/p/73701286

https://www.mydailytutorials.com/category/tutorials/ansible/page/5/

https://www.middlewareinventory.com/blog/ansible-lineinfile-examples/

https://www.unixarena.com/2019/05/passing-variable-from-one-playbook-to-another-playbook-ansible.html/

https://www.unixarena.com/2019/07/how-to-boost-ansible-playbook-speed.html/


########################################################
lineinfile  with file backup 

---
- name: Playbook Sample
  hosts: web
  become: true
  tasks:
    - name: install libselinux-python
      yum:
        name: libselinux-python
        state: present

    - name: root change sshd 
      lineinfile:
        dest: /etc/ssh/sshd_config
        regexp: '^PermitRootLogin\s+'
        line: PermitRootLogin no
        validate: sshd -t -f %s
        backup: yes
      notify:
        - sshdRestart

  handlers:
    - name: sshdRestart
      service:
        name: sshd
        state: restarted

##########################################################



---
- name: Playbook Sample
  hosts: web
  become: true
  tasks:
    - name: install libselinux-python
      yum:
        name: libselinux-python
        state: present

    - name: root change sshd 
      lineinfile:
        dest: /etc/ssh/sshd_config
        regexp: '^PermitRootLogin\s+'
        line: PermitRootLogin no
        validate: sshd -t -f %s
        backup: yes
      notify:
        - sshdRestart

    - name: SSH | Configure SSH Strict Mode
      lineinfile:
        dest: /etc/ssh/sshd_config
        regexp: '#StrictModes yes'
        line: 'StrictModes yes'
        validate: sshd -t -f %s
      notify:
        - sshdRestart 

    - name: SSH | Configure SSH Pubkey Auth
      lineinfile:
        dest: /etc/ssh/sshd_config 
        regexp: 'PubkeyAuthentication yes'
        line: 'PubkeyAuthentication yes'
        validate: sshd -t -f %s
      notify:
        - sshdRestart 

    - name: SSH | Configure SSH Agent Forwarding
      lineinfile:
        dest: /etc/ssh/sshd_config 
        regexp: '#AllowAgentForwarding yes'
        line: 'AllowAgentForwarding no'
        validate: sshd -t -f %s
      notify:
        - sshdRestart 

    - name: SSH | Configure SSH Tcp Forwarding
      lineinfile:
        dest: /etc/ssh/sshd_config 
        regexp: '#AllowAgentForwarding yes'
        line: 'AllowTcpForwarding no'
        validate: sshd -t -f %s
      notify:
        - sshdRestart

    - name: SSH | Configure SSH X11 Forwarding
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: 'X11Forwarding yes'
        line: 'X11Forwarding no'
        validate: sshd -t -f %s
      notify:
        - sshdRestart

  handlers:
    - name: sshdRestart
      service:
        name: sshd
        state: restarted





#############################
systctl 

---
- hosts: all
  gather_facts: false
  become: true
  vars:
    ansible_python_interpreter: /usr/bin/python3
    sysctl_config:
      net.ipv4.ip_forward: 1
      net.ipv4.conf.all.forwarding: 1
      net.ipv6.conf.all.forwarding: 1

  tasks:
   - name: Change various sysctl-settings
     sysctl:
       name: '{{ item.key }}'
       value: '{{ item.value }}'
       sysctl_set: yes
       state: present
       reload: yes
       ignoreerrors: yes
     with_dict: '{{ sysctl_config }}'





####################################################

Create User on REMOTE SERVER)
---
- hosts: all
  become: true
  gather_facts: no
  
vars:
  username: ramadoss
  shell: /bin/bash
  password: test123
tasks:
- name: create user
  username: "{{ username }}"
  shell: "{{ shell }}"
  password: "{{ password | password_hash('sha512') }}"


#############################################
DYNAMICALLY CREATING SAME THING:
    ---
    - hosts: all
      become: true
      gather_facts: no
  
    vars_prompt:
    - name: "username"
      prompt: "Please enter Username"
      private: no
    - name: "shell"
      prompt: "Please specify shell"
      private: no
    - name: "password"
      prompt: "Please enter Password"
      private: yes

    tasks:
    - name: create user
      user:
      name: "{{ username }}"
      shell: "{{ shell }}"
      password: "{{ password | password_hash('sha512') }}"


############################################################################
DISPLAY ALL THE OPTION AND ITS OUTPUT ON DEBUG SCREEN

---
 - hosts: all
   become: true
   gather_facts: no
   tasks:

   - name: check the disk space
     command: df -hT
     register: disk
   - debug: var=disk.stdout_lines

   - name: checking RAM Space
     command: free -m
     register: disk1
   - debug: var=disk1.stdout_lines

   - name: checking virtual memory space
     command: vmstat
     register: disk2
   - debug: var=disk2.stdout_lines

   - name: checking process list
     command: ps aux
     register: disk3
   - debug: var=disk3.stdout_lines

   - name: Check versions of ansible
     command: ansible --version
     register: disk4
   - debug: var=disk4.stdout_lines
   
#################################################################################################### 
   



Parallel vs Serial Task:
With parallel task running in playbook:

[dev01@controller lab1]$ cat parallel.yml 
---
- hosts: all
  gather_facts: no

  tasks:

  - name: sleep for 5 seconds
    shell: /bin/sleep 5


vagrant@mgmt:~$ ansible-playbook parallel.yml   -CD
PLAY [all] ******************************************************************************************************************************************************************************

TASK [sleep for 5 seconds] *********************************************************************************************************************************************************************************
skipping: [lb]
skipping: [web2]
skipping: [web1]

PLAY RECAP ******************************************************************************************************************************************************************************
lb                         : ok=0    changed=0    unreachable=0    failed=0   
web1                       : ok=0    changed=0    unreachable=0    failed=0   
web2                       : ok=0    changed=0    unreachable=0    failed=0   




With serial task running in playbook:
[dev01@controller lab1]$ cat serial.yml  
---
- hosts: all
  gather_facts: no
  serial: 1

  tasks:

  - name: sleep for 5 seconds
    shell: /bin/sleep 5




IF YOU WANT TO COPY OUTPUT TO SOMEFILE
ansible-playbook commands.yml > output
ls -l
vim output
COPY FILE FROM REMOTE TO REMOTE
---
- hosts: webserver01
  become: true
  gather_facts: no

tasks:
- name: copy file from ubuntu server to centos
  synchronize:
     src: /home/ubuntu/ubuntu_file
     dest: /home/centos/
     mode: pull
  delegate_to: dbserver01
CONDITIONALLY INSTALL APACHE AND HTTPD ON CENTOS AND UBUNTU
---
- hosts: all
  become: True
  gather_facts: yes

tasks:
- name: Install apache httpd on dbserver01
  yum: name=httpd state=present
  when: ansible_os_family=="RedHat"

- name: Start Apache httpd httpd
  service: name=httpd state=started
  when: ansible_os_family=="RedHat"

- name: Install Apache2 on webserver01
  apt: name=apache2 state=present
  when: ansible_os_family=="Debian"

- name: Start Apache
  service: name=apache2 state=started
  when: ansible_os_family=="Debian"

- name: Check Apache status
  command: systemctl status httpd
  when: ansible_os_family=="RedHat"

- name: check Apache status
  command: systemctl status apache2
  when: ansible_os_family=="Debian"
USING TAG WE CAN DISPLAY ONLY TAGGED ONE
---
- hosts: all
  become: true
  gather_facts: no

tasks:
- name: check the disk space
  command: df -hT
  register: disk
  tags: disktag
- debug: var= disktag.stdout_lines

- name: checking RAM Space
  command: free -m
  register: disk1
  tags: ramtag
- debug: var= ramtag.stdout_lines

- name: checking virtual memory space
  command: vmstat
  register: disk2
  tags: virtualtag
- debug: var= virtualtag.stdout_lines

- name: checking process list
  command: ps aux
  register: disk3
  tags: processtag
- debug: var= processtag.stdout_lines

- name: Check versions of ansible
  command: ansible --version
  register: disk4
  tags: versiontag
- debug: var=versiontag.stdout_lines



HOW TO RUN = ansible-playbook tags.yml --tags versiontag




--- # include task playbook
- hosts: all
  user: ansible
  sudo: yes
  connection: ssh
  gather_facts: no
  tasks:
   - name: echo task
     raw: echo "mohan" >> /home/ansible/var.log
     tags:
      - echotask
   - name: list task
     raw: ls -la /home/ansible >> /home/ansible/var.log
     tags:
      - listtask
# ansible-playbook tags.yml --tags "listtask"






HOW TO RUN Once 



--- # Run-once playbook
- hosts: all
  user: ansible
  sudo: yes
  connection: ssh
  gather_facts: no
  tasks:
   - name: list
     raw: ls -la /var > /home/ansible/var.log
     async: 300
     poll: 3
     run_once: true
     delegate_to: localhost
	 
	 

conditionals 

# ansible all -m setup -a "filter=ansible_os_family"
--- # conditional playbook
- hosts: all
  user: ansible
  sudo: yes
  connection: ssh
  gather_facts: yes
  tasks:
   - nmae: install apache for debain
     command: apt-get -y install apache2
     when: ansible_os_family == "Debian"
   - name: install apache for redhat
     command: yum -y install httpd
     when: ansible_os_family == "RedHat"
 
 # another way    
---# conditional playbook
- hosts: all
  user: ansible
  sudo: yes
  connection: ssh
  gather_facts: yes
  tasks:
   - nmae: install apache for debain
     apt: name=apache2 state=present
     when: ansible_os_family == "Debian"
   - name: install apache for redhat
     yum: name=httpd state=present
     when: ansible_os_family == "RedHat"
	 

# Playbook with conditional example
---
- name: Playbook with conditional example
  hosts: labservers
  tasks:
   - name: Check conditional in ansible
     shell: uptime
     register: uptime_stat
     when: ansible_hostname == 'ansible-node2'
     
   - name: Display uptime
     debug: var=uptime_stat
	 
	 

###############shell command only for redhatsystems



---
- name: Conditional Example
  hosts: testserver
  tasks:
    - name: Run a shell command only for debian systems
      shell: echo "only on Debian Family systems"
      when: ansible_os_family == "Debian"

    - name: Run a shell command only for redhatsystems
      shell: echo "only on Red Hat Family systems"
      when: ansible_os_family == "RedHat"

    - name: Run a shell command only for CentOS 6 or Debian 7
      shell: echo "only on CentOS 6 or Debian 7 systems"
      when: (ansible_distribution == "CentOS" and ansible_distribution_major_version == "6") or
            (ansible_distribution == "Debian" and ansible_distribution_major_version == "7")

    - name: Run a loop conditional
      command: echo {{ item }}
      with_items: [ 0, 2, 4, 6, 8, 10 ]
      when: item > 5


	  
	 
###############################################


playbooks-advanced


blocks




	 
	 
filters


---
- name: show some filters
  hosts: testserver
  vars:
    test_list:
      - 1
      - 2
      - 3
      - 4
      - 5
      - 5
      - 2

  tasks:
    - name: show a to_json filter
      debug: msg="to_json filter {{group_specific_var|to_json}}"

    - name: show a to_yaml filter
      debug: msg="to_yaml filter {{group_specific_var|to_yaml}}"

    - name: defaulting undefined variables
      debug: msg="defaulting undefined variables - {{non_existant|default(5)}}"

    - name: list filter min
      debug: msg="list filter min - {{test_list|min}}"

    - name: list filter max
      debug: msg="list filter max - {{test_list|max}}"

    - name: list filter unique
      debug: msg="list filter unique - {{test_list|unique}}"

    - name: list filter shuffle
	
	
	


################################
wait 


---

- name: Run tasks in parallel
  hosts: localhost
  connection: local
  gather_facts: no
  tasks:
    - name: Pretend to create instances
      command: "sleep {{ item }}"  # Instead of calling a long running operation at a cloud provider, we just sleep.
      with_items:
        - 6
        - 8
        - 7
      register: _create_instances
      async: 600  # Maximum runtime in seconds. Adjust as needed.
      poll: 0  # Fire and continue (never poll)

    - name: Wait for creation to finish
      async_status:
        jid: "{{ item.ansible_job_id }}"
      register: _jobs
      until: _jobs.finished
      delay: 5  # Check every 5 seconds. Adjust as you like.
      retries: 10  # Retry up to 10 times. Adjust as needed.
      with_items: "{{ _create_instances.results }}"
	  
	  
########################################################################	  


---

- name: Run tasks in parallel
  hosts: localhost
  connection: local
  gather_facts: no
  tasks:
    - name: Pretend to create instances
      command: "sleep {{ item }}"  # Instead of calling a long running operation at a cloud provider, we just sleep.
      with_items:
        - 6
        - 8
        - 7
      register: _create_instances
      async: 600  # Maximum runtime in seconds. Adjust as needed.
      poll: 0  # Fire and continue (never poll)

    - name: Wait for creation to finish
      async_status:
        jid: "{{ item.ansible_job_id }}"
      register: _jobs
      until: _jobs.finished
      delay: 5  # Check every 5 seconds. Adjust as you like.
      retries: 10  # Retry up to 10 times. Adjust as needed.
      with_items: "{{ _create_instances.results }}"
	  
	  
	  



#####################################	


*List all tasks in the playbook 
* ansible-playbook playbook.yml --list-tasks
*Start the play from a particular task 
*ansible-playbook playbook.yml --start-at-task="task name" 
*Start the play step by step with interactive way. This will prompt the user for to confirm each task before running. 
*ansible-playbook playbook.yml --step 
Check syntax of the playbook 
ansibe-playbook playbook.yml --syntax-check 
Execute the playbook in the check (dry-run) mode ,which check what changes will be performed.
ansible-playbook playbook.yml --check 
List hosts on which playbook will be executed 
ansible-playbook playbook.yml --list-hosts -1 subset 
List tags in the playbook 
ansible-playbook playbook.yml --list-tags 
Only run plays and tasks tagged with these tag values 
ansible-playbook playbook.yml --tags tagl,tag2...tagN 
Skip the tasks associated with specific tasks 
ansible-playbook playbook.yml --skip-tags tag1,tag2...tagN 


CREATE EC2 INSTANCE USING ANSIBLE
Install following pip and boto
Easy-install pip
Pip install boto
Create IAM user
Create user
Full Adminaccess
Download csv file
ec2user.yml

---
- name: Create EC2 instances
  hosts: localhost
  gather_facts: no

vars:
  region: us-east-1
  instance_type: t2.micro
  image: ami-97785bed
  group: Ansible_demo
  key_name: Abhi

# check ec3 docs

tasks:
- name: Launch Instance
  ec2:
    region: "{{ region }}"
    instance_type: "{{instance_type }}"
    image: "{{ image }}"
    group: "{{ group }}"
    key_name: "{{ key_name }}"
    aws_access_key: 
    aws_secret_key: 
    wait: true
    register: ec2_output
- debug: var=ec2_output
ENCLOSE SECRET KEY


Ansible vault – to store our secret keys in encrypted manner
ansible-vault --help Usage: ansible-vault [create|decrypt|edit|encrypt|encrypt_string|rekey|view] [options] [vaultfile.yml]
ansible-vault create aws_key.yml • sekey: aws secret key • ackey: aws access key
ansible-vault view aws_key.yml
ansible-vault rekey aws_key.yml
ansible-vault edit aws_key.yml
ansible-vault decrypt aws_key.yml
1st method
To execute ansible vault ec2.yml.

sudo ansible-playbook ec2.yml - -ask-vault-pass

2nd method


vim .keys.txt
password
wq!

sudo ansible-playbook ec2.yml - -vault-password-file .keys.txt



3rd method
Mention keys.yml file in ansible.cfg file

vim ansible.cgf 
Add at the end  Vault_password_file=./.keys.txt
wq!

sudo ansible-playbook ec2.yml





Run playbook.

Assuming you ran the adhoc commands a ansible user already exists that can sudo. If not you need to run the adhoc commands.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
We can use the newly created Ansible user and the -b option (become root) to elevate permissions.

Variables
Variables allow for dynamic input. In Ansible variables can be defined in many ways such as: playbook itself, inventory file via host or group vars, cli via extra_vars or in a separate vars file that can be included in playbook. Let’s take a look at these options in more detail. Instead of hard-coding the username we created above let’s explore doing so using the different variable options.

Vars via inventory file.

Variables can be defined for a host or group in the inventory file itself. Here we will define a variable username for the group servers.

Update inventory file and add vars for group servers.

$ vi inventory

[servers]
server1.lab.com
server2.lab.com
server3.lab.com
server4.lab.com

[servers:vars]
username=ansible
Update playbook to use variables.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers

  tasks:
    - name: Add a user
      user:
        name: "{{ username }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ username }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
Notice that the variable {{ username }} needs quotes only when it starts a line.

Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Variables in playbook

Variables can be defined directly in the playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars:
    username: ansible

  tasks:
    - name: Add a user
      user:
        name: "{{ username }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ username }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Variables imported from vars file.

Similar to above example, variables can be defined in a separate file and then imported into playbook.

Create vars file.

$ vi my_vars.yml
---
username: ansible
Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Add a user
      user:
        name: "{{ username }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ username }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
The best practice #3 is to use inventory file to define key/value type variables that should be parameterized. Variables that are dynamically generated or utilize nested data structures should use vars_files and be included. Avoid using vars in playbook directly if possible.

Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Ansible Facts
Each time Ansible is run unless disabled the setup module is also run. The setup module gathers Ansible facts. These are variables that give us valuable information about the managed host and they can be acted upon within playbooks.  Anything from a hosts network, hardware and OS information are gathered. It is also possible to define custom facts that would be gathered.

View ansible facts for a host.

$ ansible -m setup -u ansible -b -i ./inventory servera.lab.com
Use ansible facts in playbook.

Here we will print the memory and number of cpu cores in our playbook by adding a new task.

$ vi add_user.yml
---
    - name: Print Memory and CPU Cores
      debug:
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
---
Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Controlling Playbooks
We have seen how to use modules to drive tasks and even parameterize them with variables. Next we will understand how to better control tasks within those playbooks.

When Conditional

This acts as an if statement in common programming languages. In Ansible we use when statement to run a task based on a condition being met.

Execute add user only when username is defined.

$ vi add_user.yaml
---
    - name: Add a user
      user:
        name: "{{ username }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
      when: username is defined
---
Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Loops

In Ansible loops are very useful when the same task or module need to execute against a list. In our playbook let’s update it to take action on many users and thus show how to use a loop.

Update vars file.

$ vi my_vars.yml
---
users:
  - ansible
  - bob
  - joe
  - keith
Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Print Memory and CPU Cores 
      debug: 
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
    - name: Add a user
      user:
        name: "{{ item }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ item }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Handlers

In order to couple tasks or have a task executed from another task, a handler is required. Here we will look at converting the “configure sudo permission” task into a handler that can be triggered by the “add a user” task.

Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Print Memory and CPU Cores 
      debug: 
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
    - name: Add a user
      user:
        name: "{{ item }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
      notify:
        - 'Configure sudo permission'

  handlers:
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ item }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
Now sudo permissions will only be set when a new user is actually added. It is very important to understand behavior with handlers, a notifer will only run when the task made a change.

Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
Tags

It may be desired to only run certain tasks and to control which tasks get run from cli. This is done in Ansible via tags. Lets set a tag which will only run the task that prints memory and cpu info.

Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Print Memory and CPU Cores 
      debug: 
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
      tags:
        - info
    - name: Add a user
      user:
        name: "{{ item }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
      notify:
        - 'Configure sudo permission'

  handlers:
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ item }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
Run playbook using tag ‘info’.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory --tags 'info'
Blocks

In order to handle errors in Ansible blocks are often used. The block statement defines the main task to run. The rescue statement defines a task that should run if an error is encountered inside the block. Here we will setup error handling for our add user task.

Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Print Memory and CPU Cores 
      debug: 
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
      tags:
        - info
    - block:
        - name: Add a user
          user:
            name: "{{ item }}"
            shell: /bin/bash
            generate_ssh_keys: yes
            state: present
          with_items: "{{ users }}"
          when: item is defined
          notify:
            - 'Configure sudo permission'
      rescue:
        - name: revert user add
          user: 
            name: "{{ item }}" 
            state: absent 
          with_items: "{{ users }}" 
          when: item is defined         
  handlers:
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ item }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
The playbook will now attempt to remove users if an error occurs with the add user task. You can simulate this by adding a new user to my_vars.yml file and running without the -b (become root) option.

Run playbook.

$ ansible-playbook add_user.yml -u ansible -i ./inventory
Templates
In Ansible templates are used mostly to parameterize configuration files. Ansible uses the jinja2 templating system. A template module is provided that defines the template and where it should be placed. Variables are automatically substituted for their values when the template is copied to its destination. We will add a new task to the playbook which sets the motd using hostname as a dynamic variable from a motd jinja2 template.

Create a jinja2 template for motd.

$ vi motd.j2
Ansible Rocks!!! This is host {{ ansible_hostname }}.
Update playbook.

$ vi add_user.yml
---
- name: Add a privileged user for Ansible
  hosts: servers
  vars_files:
    - ./my_vars.yml

  tasks:
    - name: Configure MOTD using template
      template:
        src: ./motd.j2
        dest: /etc/motd
        owner: root
        group: root
        mode: 0644
    - name: Print Memory and CPU Cores 
      debug: 
        msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
      tags:
        - info
    - block:
        - name: Add a user
          user:
            name: "{{ item }}"
            shell: /bin/bash
            generate_ssh_keys: yes
            state: present
          with_items: "{{ users }}"
          when: item is defined
          notify:
            - 'Configure sudo permission'
      rescue:
        - name: revert user add
          user: 
            name: "{{ item }}" 
            state: absent 
          with_items: "{{ users }}" 
          when: item is defined         
  handlers:
    - name: Configure sudo permission
      lineinfile:
        dest: /etc/sudoers.d/{{ item }}
        line: 'ansible ALL=(ALL) NOPASSWD: ALL'
        create: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
Run playbook.

$ ansible-playbook add_user.yml -u ansible -b -i ./inventory
The playbook will now update motd based on our jinja2 template. The hostname will be dynamically applied based on the variable.

Check MOTD.

$ ssh -l ansible server1
Ansible Rocks!!! This is host server1.
Roles
Now that we have a good understanding about playbooks it is time to move on to roles. In Ansible roles allow Ansible to be reusable. The Ansible community provides galaxy which allows community members to share roles. There are 1000s of roles so often if you want to do something in Ansible, there is probably already a roll that exists in galaxy to do so. You can also easily modify roles to fit intended purpose. We now come to best practice #4, don’t be lazy, always create roles. Not only will roles allow you to share your playbook packages with others, but will also enforce good structuring , clean code and allow you to re-use role components in ways that were not even considered. We will now restructure our playbook tasks, variables, handlers and templates into a add user role.

Create empty role structure.

The ansible-galaxy command allows lists, installs and removes roles from galaxy. It also generates the empty structure of a role, useful for creating your own roles. Here we will create the empty structure for our new add_user role.

$ ansible-galaxy init --offline -p roles add_user
 Create role tasks.

Now we will move the tasks from our playbook into the role. A simply copy/paste and delete of the first four empty spaces of each line will suffice.

$ vi roles/add_user/tasks/main.yml
---
- name: Configure MOTD using template
  template:
    src: ./motd.j2
    dest: /etc/motd
    owner: root
    group: root
    mode: 0644
- name: Print Memory and CPU Cores 
  debug: 
    msg: "Host {{ ansible_hostname }} has {{ ansible_memtotal_mb }} MB Memory and {{ ansible_processor_cores }} CPU Cores."
  tags:
    - info
- block:
    - name: Add a user
      user:
        name: "{{ item }}"
        shell: /bin/bash
        generate_ssh_keys: yes
        state: present
      with_items: "{{ users }}"
      when: item is defined
      notify:
        - 'Configure sudo permission'
  rescue:
    - name: revert user add
      user: 
        name: "{{ item }}" 
        state: absent 
      with_items: "{{ users }}" 
      when: item is defined
Create role handlers.

Similar to tasks handlers also have a specific location within a role. Again copy/paste and delete of the first four spaces of each line.

$ vi roles/add_user/handlers/main.yml
---
- name: Configure sudo permission
  lineinfile:
    dest: /etc/sudoers.d/{{ item }}
    line: 'ansible ALL=(ALL) NOPASSWD: ALL'
    create: yes
    state: present
  with_items: "{{ users }}"
  when: item is defined
Create role vars.

Variables for a role can be stored under vars or default. In this case we will put them under vars.

$ vi roles/add_users/vars/main.yml
--- 
users: 
  - ansible 
  - bob 
  - joe 
  - keith
Create role templates.

Templates simply need to be copied to the correct location.

$ cp motd.j2 roles/add_user/templates
Create playbook that uses role.

$ vi add_user_using_role.yml
---
- name: Add user using role
  hosts: servers
  roles:
    - add_user
Run playbook.

$ ansible-playbook add_user_using_role.yml -u ansible -b -i ./inventory
The playbook will now execute our role. As you have seen roles provide a pre-defined structuring and packaging of playbook tasks that greatly enhances re-usability.

Summary
In this article we have discussed the need and great opportunity automation provides. We have explored the basics of Ansible and why Ansible has become the standard language of automation. This article attempts to provide a pragmatic approach to learning Ansible, from installation, adhoc commands, creating your first playbook , learning fundamentals and finally putting it all together in a role. The greatest thing you can do for yourself and your organization is to automate everything.













Create empty role structure.

The ansible-galaxy command allows lists, installs and removes roles from galaxy. 
It also generates the empty structure of a role, useful for creating your own roles. 
Here we will create the empty structure for our new add_user role.

$ ansible-galaxy init --offline -p roles add_user



Chapter 4. Make a complex playbook

-Repeat-with_items

-Save output for later use-register

-Conditional execution-when

-Repeat until successful-until

-Reference external information-lookup

-Process variables-filter

-Type from the keyboard-vars_prompt

-Run on admin host-local_action

-Change the module to be executed with a variable-action

-Set environment variables-environment

-Ignore on failure-ignore_errors

-Execute task asynchronously-async

Chapter 5. Build a large playbook

-Load other playbooks-include

-Recommended directory structure-best practices

-Reuse in bulk-role

-Parallel execution-fork

-Run in sequence-serial

-Cooperation with AWS EC2

-Dynamic list of hosts-dynamic inventory

Chapter 6. Using command line options

-ssh authentication

-Limit target hosts-limit

-Limit the tasks to be executed-tag

-Run dry-run-check

-Execute while checking task-step

-Differential representation-diff

Chapter 8. Let's use the public role-Ansible Galaxy

- Ansible Galaxyとは

-How to search for role

-Get a role

-How to use role

Chapter 9. Frequently Asked Questions

- can not connect

-ControlPath too long error

-Even if you run it, it stops halfway

-I want to connect without an inventory file

-One playbook has become complicated

-I get a python not found error

-I want to use it on Windows

-Strange pictures are displayed in ansible-playbook

-I want to know the variables that ansible collects

-I get invalid type type 'list'

-"Syntax Error" when using variables

-What does "---" mean?

-What is the origin of the name Ansible?

Chapter 10. Conclusion

Appendix: Creating your own module

-Module behavior

-Module format

-Module sample

-Convenience functions in Python

-Module debugging

Appendix: Ansible plugin

-plugin type

- lookup plugin

- filter plugin

- callback plugin

- action plugin

- connection type plugin

- fresh plugin

Appendix: ansible config file

-default section

-paramiko section

-ssh_connection section

-accelerate section

Appendix: Windows compatible

-Prerequisite environment

-Ready

-inventory file

- module

-Limitations

ansible target_host -i inventory_file -m shell -a 'echo "Hello World"'

ansible target_host -m ping -i inventory_file -u root

ansible target_host -m service -a "name=httpd state=started"

ansible target_host -m user -a "name=username password=<crypted password here>"

3.2.ansible-playbook

ansible-playbook -i inventory_file playbook.yml

ansible-playbook -i inventory_file playbook.yml --syntax-check

ansible-playbook -i inventory_file playbook.yml --list-tasks

ansible-playbook -i inventory_file -u root -k playbook.yml -vvv

ansible-playbook --extra-vars "xxx=yes" -i inventory_file playbook.yml

ansible-playbook -e "xxx=yes" -i inventory_file playbook.yml

ansible-playbook -i inventory_file playbook.yml --private-key=/path/key.pem

3.3.ansible-doc
ansible-doc -l

Check role version
ansible-galaxy list --roles-path <role path>


ansible-playbook -i inventory -u {username} playbool.yml --ask-become-pass

ansible-playbook -i i[hosts] site.yml

ansible-playbook -i [hosts] webservers.yml


ansible-playbook -i [hosts] --limit 
tag

ansible-playbook -i [hosts] --tags 
task

ansible-playbook -i [hosts] webservers.yml --tags ntp --list-tasks
hosts

ansible-playbook -i [hosts] webservers.yml --tags ntp --list-hosts

ansible-playbook deploy_devops.yml --syntax-check










